////
/// Smoother background gradients.
///
/// The default background gradients produced by any browser have a quite harsh transition between
/// colors. This is especially apparent if you, for example, use a strong fade-out gradient to make
/// text in front of a background more readable.
///
/// The function in this file generates smoother gradients by using an easing function of the user's
/// choice.
/// It's essentially a more flexible alternative to the PostCSS plugin "PostCSS Easing Gradients":
/// https://github.com/larsenwork/postcss-easing-gradients
///
/// @group Background gradients
///
/// @access public
////

///
/// Number of easing steps. The lower the value, the more fine-grained are the steps and the better is
/// the quality. However, a value of 0.1 is perfectly sufficient and I wouldn't recommend changing it.
///
/// @type number
///
$ig-easing-gradient-precision: 10 !default;

/// 
/// Generate a new easing background gradient.
/// This function is intended to be as similar as possible to CSS' built-in linear-gradient and radial-gradient,
/// without losing on flexibility. The only major drawback of this function is that only two colors can be used.
///
/// @param {string}       $type                - Either 'linear' or 'radial', which means the gradient will be either a linear-gradient or a radial-gradient.
/// @param {string}       $easing              - Easing function to use. For the integrated easing functions, you may leave out the "ig-ease-" prefix.
/// @param {string}       $dir                 - The direction of the gradient. Depending on $type, this value must be a valid direction for linear-gradient or radial-gradient.
/// @param {color | list} $start               - The start color. You may change the start position (default: 0) to another value by passing a list instead, with the first item being the color and the second item being the position.
/// @param {color | list} $stop                - The stop color. You may change the stop position (default: 100%) to another value by passing a list instead, with the first item being the color and the second item being the position.
/// @param {string}       $pos-template [null] - The template string for the position value of each step, where each instance of a certain substring (can't note it here because it breaks SassDoc, so see example below) is replaced with the percentage (between 0 and 1 inclusive) of the intermediate position. This is useful if you want to use complex positions with calc() that can't be automatically interpolated.
///
/// @return {string} A linear-gradient or radial-gradient with an alternative transitioning behavior.
///
/// @throw If $type is invalid
///
/// @example scss - A smoother linear gradient
///   .background {
///     background-image: ig-easing-gradient(
///       linear,
///       to top,
///       #000,
///       in-out-sine,
///       transparent
///     );
///   }
///   
///   // Generates:
///   
///   .background {
///     background-image: linear-gradient(
///       to top,
///       black                        0%,
///       rgba(0, 0, 0, 0.975528)     10%,
///       rgba(0, 0, 0, 0.904508)     20%,
///       rgba(0, 0, 0, 0.793893)     30%,
///       rgba(0, 0, 0, 0.654508)     40%,
///       rgba(0, 0, 0, 0.5)          50%,
///       rgba(0, 0, 0, 0.345492)     60%,
///       rgba(0, 0, 0, 0.206107)     70%,
///       rgba(0, 0, 0, 0.0954915)    80%,
///       rgba(0, 0, 0, 0.0244717)    90%,
///       rgba(0, 0, 0, 3.78257e-11) 100%
///     );
///   }
///
/// @example scss - A smoother radial gradient
///   .background {
///     background-image: ig-easing-gradient(
///       radial,
///       50em 16em at 0 0,
///       #000,
///       in-out-sine,
///       transparent
///     );
///   }
///   
///   // Generates:
///   
///   .background {
///     background-image: radial-gradient(
///       50em 16em at 0 0,
///       black                        0%,
///       rgba(0, 0, 0, 0.975528)     10%,
///       rgba(0, 0, 0, 0.904508)     20%,
///       rgba(0, 0, 0, 0.793893)     30%,
///       rgba(0, 0, 0, 0.654508)     40%,
///       rgba(0, 0, 0, 0.5)          50%,
///       rgba(0, 0, 0, 0.345492)     60%,
///       rgba(0, 0, 0, 0.206107)     70%,
///       rgba(0, 0, 0, 0.0954915)    80%,
///       rgba(0, 0, 0, 0.0244717)    90%,
///       rgba(0, 0, 0, 3.78257e-11) 100%
///     );
///   }
///
/// @example scss - A smoother linear gradient with complex color positions
///   .background {
///     background-image: ig-easing-gradient(
///       linear,
///       to top,
///       #000 20%,
///       in-out-sine,
///       transparent calc(20% + 25em)
///     );
///   }
///   
///   // Generates:
///   
///   .background {
///     background-image: linear-gradient(
///       to top,
///       black                    20%,
///       rgba(0, 0, 0, 0.975528)  calc(20% + (20% + 25em - 20%) * 0.1),
///       rgba(0, 0, 0, 0.904508)  calc(20% + (20% + 25em - 20%) * 0.2),
///       rgba(0, 0, 0, 0.793893)  calc(20% + (20% + 25em - 20%) * 0.3),
///       rgba(0, 0, 0, 0.654508)  calc(20% + (20% + 25em - 20%) * 0.4),
///       rgba(0, 0, 0, 0.5)       calc(20% + (20% + 25em - 20%) * 0.5),
///       rgba(0, 0, 0, 0.345492)  calc(20% + (20% + 25em - 20%) * 0.6),
///       rgba(0, 0, 0, 0.206107)  calc(20% + (20% + 25em - 20%) * 0.7),
///       rgba(0, 0, 0, 0.0954915) calc(20% + (20% + 25em - 20%) * 0.8),
///       rgba(0, 0, 0, 0.0244717) calc(20% + (20% + 25em - 20%) * 0.9),
///       transparent              calc(20% + 25em))
///     );
///   }
///
@function ig-easing-gradient($type, $dir, $stop, $stops...) {
    $pos-template: null;
    $stops:        ig-list-prepend($stops, $stop);

    $last-positioned-stop: 1;
    $generated-stops:      ();

    @for $i from 1 through length($stops) {
        $stop: nth($stops, $i);

        @if ((type-of($stop) == list) and (type-of(nth($stop, 1)) == color) and ($i != 1)) or ($i == length($stops)) {
            @if not ig-easing-gradient-is-color-stop($stop) {
                @error 'The last color stop argument must be a color stop.';
            }

            //
            // Either the current stops list item is a positioned color stop, or the end of
            // the stops list has been reached.
            //

            @if (type-of($stop) == color) and ($i == length($stops)) {
                //
                // The current stop is an unpositioned color stop, which means this is the end
                // of the stops list. The default position for the last color stop is 100%, which
                // is explicitly added for easier calculations.
                //

                $stop:  $stop 100%;
                $stops: set-nth($stops, $i, $stop);
            }

            //
            // Now the current color stop is guaranteed to be a positioned color stop.
            //

            @if $i > $last-positioned-stop + 1 {
                //
                // There is at least one unpositioned color stop item between the last positioned
                // color stop and the current current stops list item. Interpolate their positions.
                //

                $interpolated-stops: ig-easing-gradient-interpolate-stop-positions(
                    nth($stops, $last-positioned-stop),
                    ig-list-slice($stops, $last-positioned-stop + 1, $i - 1),
                    $stop
                );

                $new-stops: join(
                    ig-list-slice($stops, 1, $last-positioned-stop),
                    $interpolated-stops
                );
                $new-stops: join(
                    $new-stops,
                    ig-list-slice($stops, $i)
                );
                $stops: $new-stops;
            }

            //
            // Now all color stops between this one and the last positioned one have
            // interpolated positions.
            // Next task is to perform an easing transition between all color stops that
            // have an easing function specified. The rest can be left alone since the
            // browser will automatically apply a linear transition between them.
            //

            $j: $last-positioned-stop + 1;
            @while $j <= $i {
                $easing:    null;
                $prev-stop: nth($stops, $j - 1);
                $next-stop: nth($stops, $j);

                @if not ig-easing-gradient-is-color-stop($next-stop) {
                    $j: $j + 1;

                    $easing:    $next-stop;
                    $next-stop: nth($stops, $j);
                }

                @if $easing != null {
                    $easing-func: null;
                    $easing-args: ();

                    @if type-of($easing) == list {
                        $easing-args: ig-list-slice($easing, 2);
                        $easing:      nth($easing, 1);
                    }

                    @if function-exists('ig-' + $easing) {
                        $easing-func: get-function('ig-' + $easing);
                    } @else {
                        $easing-func: get-function($easing);
                    }

                    $generated-stops: join(
                        $generated-stops,
                        ig-easing-gradient-ease-stops($prev-stop, $next-stop, $easing-func, $easing-args),
                        comma
                    );
                } @else {
                    $generated-stops: append($generated-stops, ig-str-implode($next-stop, ' '));
                }

                $j: $j + 1;
            }

            $last-positioned-stop: $i;
        } @else if ($i == 1) {
            @if not ig-easing-gradient-is-color-stop($stop) {
                @error 'The first color stop argument must be a color stop.';
            }

            @if type-of($stop) == color {
                //
                // The first color stop is unpositioned. The default position for the first
                // color stop is 0, which is explicitly added for easier calculations.
                //

                $stop:  $stop 0;
                $stops: set-nth($stops, $i, $stop);
            }
        }

        @if $i == 1 {
            $generated-stops: append($generated-stops, ig-str-implode($stop, ' '));
        }
    }

    @if $type == 'linear' {
        @return linear-gradient($dir, unquote(ig-str-implode($generated-stops, ', ')));
    } @else if $type == 'radial' {
        @return radial-gradient($dir, unquote(ig-str-implode($generated-stops, ', ')));
    } @else {
        @error 'Invalid gradient type: #{inspect($type)}.';
    }
}

///
/// Alias for ig-easing-gradient('linear',...)
///
/// @see {function} ig-easing-gradient
///
@function ig-easing-linear-gradient($dir, $stop, $stops...) {
    @return ig-easing-gradient('linear', $dir, $stop, $stops...);
}

///
/// Alias for ig-easing-gradient('radial',...)
///
/// @see {function} ig-easing-gradient
///
@function ig-easing-radial-gradient($dir, $stop, $stops...) {
    @return ig-easing-gradient('radial', $dir, $stop, $stops...);
}

///
/// Generate a smooth transition from one color stop to another using the provided easing function.
///
/// @access private
///
@function ig-easing-gradient-ease-stops($prev-stop, $next-stop, $easing-func, $easing-args: ()) {
    $prev-stop-color: nth($prev-stop, 1);
    $prev-stop-pos:   nth($prev-stop, 2);
    $next-stop-color: nth($next-stop, 1);
    $next-stop-pos:   nth($next-stop, 2);

    $stops: ();

    @if ((type-of($prev-stop-pos) == number) and (type-of($next-stop-pos) == number) and (unit($prev-stop-pos) == unit($next-stop-pos))) or ($prev-stop-pos == 0) or ($next-stop-pos == 0) {
        //
        // The transition color stop positions can be statically calculated.
        //

        $distance: $next-stop-pos - $prev-stop-pos;

        @for $i from 1 through $ig-easing-gradient-precision {
            $perc:  $i / $ig-easing-gradient-precision;

            $color: null;
            $pos:   $prev-stop-pos + $perc * $distance;
            @if $perc == 1 {
                $color: $next-stop-color;
            } @else {
                $color: mix($next-stop-color, $prev-stop-color, call($easing-func, append($easing-args, $perc)...) * 100%);
            }

            $stops: append($stops, $color + ' ' + $pos, comma);
        }
    } @else {
        //
        // The transition color stop positions have to be dynamically calculated with the calc() function.
        //

        @if type-of($prev-stop-pos) == string {
            // assuming calc()
            $prev-stop-pos: str-slice($prev-stop-pos, 6, str-length($prev-stop-pos) - 1);
        }

        @if type-of($next-stop-pos) == string {
            // assuming calc()
            $next-stop-pos: str-slice($next-stop-pos, 6, str-length($next-stop-pos) - 1);
        }

        @for $i from 1 through $ig-easing-gradient-precision {
            $perc:  $i / $ig-easing-gradient-precision;

            $color: null;
            $pos:   null;
            @if $perc == 1 {
                $color: $next-stop-color;
                $pos:   calc(#{$next-stop-pos});
            } @else {
                $color: mix($next-stop-color, $prev-stop-color, call($easing-func, append($easing-args, $perc)...) * 100%);
                $pos:   calc(#{$prev-stop-pos} + (#{$next-stop-pos} - #{$prev-stop-pos}) * #{$perc});
            }

            $stops: append($stops, $color + ' ' + $pos, comma);
        }
    }

    @return $stops;
}

///
/// Interpolate the positions of multiple color stops between two color stops whose positions are set.
///
/// @access private
///
@function ig-easing-gradient-interpolate-stop-positions($prev-stop, $stops, $next-stop) {
    $prev-stop-pos: nth($prev-stop, 2);
    $next-stop-pos: nth($next-stop, 2);

    $stops-num: 0;
    @for $i from 1 through length($stops) {
        $stop: nth($stops, $i);
        @if ig-easing-gradient-is-color-stop($stop) {
            $stops-num: $stops-num + 1;
        }
    }

    $i: 1;
    $cur-stop-num: 1;

    @if ((type-of($prev-stop-pos) == number) and (type-of($next-stop-pos) == number) and (unit($prev-stop-pos) == unit($next-stop-pos))) or ($prev-stop-pos == 0) or ($next-stop-pos == 0) {
        //
        // The color stop positions can be statically calculated.
        //

        $distance: $next-stop-pos - $prev-stop-pos;

        @for $i from 1 through length($stops) {
            $stop: nth($stops, $i);
            @if ig-easing-gradient-is-color-stop($stop) {
                $pos:   $prev-stop-pos + $distance / ($stops-num + 1) * $cur-stop-num;
                $stops: set-nth($stops, $i, $stop $pos);

                $cur-stop-num: $cur-stop-num + 1;
            }
        }
    } @else {
        //
        // The color stop positions have to be dynamically calculated with the calc() function.
        //

        @if type-of($prev-stop-pos) == string {
            // assuming calc()
            $prev-stop-pos: str-slice($prev-stop-pos, 6, str-length($prev-stop-pos) - 1);
        }

        @if type-of($next-stop-pos) == string {
            // assuming calc()
            $next-stop-pos: str-slice($next-stop-pos, 6, str-length($next-stop-pos) - 1);
        }

        @for $i from 1 through length($stops) {
            $stop: nth($stops, $i);
            @if ig-easing-gradient-is-color-stop($stop) {
                $perc:  $cur-stop-num / ($stops-num + 1);
                $pos:   calc(#{$prev-stop-pos} + (#{$next-stop-pos} - #{$prev-stop-pos}) * #{$perc});
                $stops: set-nth($stops, $i, $stop $pos);

                $cur-stop-num: $cur-stop-num + 1;
            }
        }
    }

    @return $stops;
}

///
/// Check if the input is a valid color stop.
///
/// @access private
///
@function ig-easing-gradient-is-color-stop($input) {
    @return (type-of($input) == color) or ((type-of($input) == list) and (type-of(nth($input, 1)) == color));
}
