////
/// Fluid properties.
///
/// The mixins and functions in this file allow you to scale any px- or rem-based value depending on
/// the available viewport width. One popular use case is the dynamic scaling of fonts.
///
/// The code in this file is based on an article by Niklas Postulart:
/// http://niklaspostulart.de/2015/10/sass-responsive-type-mixin
/// 
/// The following adjustments were made:
/// - Support any property passed by the user, not just font-size
/// - Allow multiple target viewports / values
/// - Provide a variant of the mixin which integrates include-media for media queries
///
/// @group Responsive
///
/// @access public
////

///
/// If true, named viewports will be supported if a compatible $breakpoints map exists.
/// This is the case for [include-media](https://include-media.com/), for example.
///
/// @type bool
///
$ig-fluid-support-named-viewports: true !default;

///
/// Context ID used for fluid environment-related mixins.
///
/// @type string
///
$ig-fluid-context-id: 'fluid' !default;

/// 
/// Scale a property uniformly between a specific set of target viewports / values.
///
/// @param {string | list} $props     - Property or list of properties to set
/// @param {number}        $fluid-map - A map with keys = viewports and values = target value
///
/// @example scss - Responsive font-size between 2 viewports
///   .something {
///     @include ig-fluid-property(font-size, ( 320px: 20px, 720px: 30px ));
///   }
///   
///   // Generates:
///   
///   @media (min-width: 320px) and (max-width: 720px) {
///     .something {
///       font-size: calc(20px + 10 * ((100vw - 20px) / 400));
///     }
///   }
///   
///   @media (max-width: 320px) {
///     .something {
///       font-size: 20px;
///     }
///   }
///   
///   @media (min-width: 720px) {
///     .something {
///       font-size: 30px;
///     }
///   }
///
/// @example scss - Responsive font-size between 3 viewports
///   .something {
///     @include ig-fluid-property(font-size, ( 320px: 20px, 720px: 30px, 1280px: 40px ));
///   }
///   
///   // Generates:
///   
///   @media (min-width: 320px) and (max-width: 720px) {
///     .something {
///       font-size: calc(20px + 10 * ((100vw - 20px) / 400));
///     }
///   }
///   
///   @media (min-width: 720px) and (max-width: 1280px) {
///     .something {
///       font-size: calc(30px + 10 * ((100vw - 30px) / 400));
///     }
///   }
///   
///   @media (max-width: 320px) {
///     .something {
///       font-size: 20px;
///     }
///   }
///   
///   @media (min-width: 720px) {
///     .something {
///       font-size: 30px;
///     }
///   }
///
@mixin ig-fluid-property($props, $fluid-map) {
    @include ig-fluid-env(map-keys($fluid-map)...) {
        @if type-of($props) == list {
            @each $prop in $props {
                #{$prop}: ig-fluid-set(map-values($fluid-map)...);
            }
        } @else {
            #{$props}: ig-fluid-set(map-values($fluid-map)...);
        }
    }
}

/// 
/// Create a new fluid environment by specifying a set of viewports.
/// Inside a fluid environment, use the ig-fluid-set function to make a property scale automatically.
///
/// @param {list} $viewports - Viewports sorted in ascending order
///
/// @content
///
/// @see {function} ig-fluid-set
///
/// @example scss - Responsive font-size between 2 viewports
///   .something {
///     @include ig-fluid-env(320px, 720px) {
///       font-size: ig-fluid-set(20px, 30px);
///     }
///   }
///   
///   // Generates:
///   
///   @media (min-width: 320px) and (max-width: 720px) {
///     .something {
///       font-size: calc(20px + 10 * ((100vw - 20px) / 400));
///     }
///   }
///   
///   @media (max-width: 320px) {
///     .something {
///       font-size: 20px;
///     }
///   }
///   
///   @media (min-width: 720px) {
///     .something {
///       font-size: 30px;
///     }
///   }
///
@mixin ig-fluid-env($viewports...) {
    @if length($viewports) <= 1 {
        @error '$viewports must contain at least two viewports.';
    }

    $new-viewports: ();

    @each $viewport in $viewports {
        @if $ig-fluid-support-named-viewports and global-variable-exists(breakpoints) {
            @if map-has-key($breakpoints, $viewport) {
                $viewport: map-get($breakpoints, $viewport);
            }
        }

        @if (type-of($viewport) != number) or unitless($viewport) {
            @error '$viewports contains invalid viewports.';
        }

        $new-viewports: append($new-viewports, $viewport);
    }

    $viewports: ig-quicksort($new-viewports);

    @if $new-viewports != $viewports {
        @error '$viewports was not sorted in ascending order.';
    }

    @for $i from 1 to length($viewports) {
        $prev-vp: nth($viewports, $i);
        $next-vp: nth($viewports, $i + 1);

        @media (min-width: $prev-vp) and (max-width: $next-vp) {
            @include ig-context-push($ig-fluid-context-id, 'env', (
                    'viewports': $viewports,
                    'mode':      transition,
                    'index':     $i
            ));

            @content;

            @include ig-context-pop($ig-fluid-context-id);
        }
    }

    $first-vp: nth($viewports, 1);
    $last-vp:  nth($viewports, length($viewports));

    @media (max-width: $first-vp) {
        @include ig-context-push($ig-fluid-context-id, 'env', (
                'viewports': $viewports,
                'mode':      first
        ));

        @content;

        @include ig-context-pop($ig-fluid-context-id);
    }

    @media (min-width: $last-vp) {
        @include ig-context-push($ig-fluid-context-id, 'env', (
                'viewports': $viewports,
                'mode':      last
        ));

        @content;

        @include ig-context-pop($ig-fluid-context-id);
    }
}

///
/// Make a property scale automatically inside a fluid environment.
///
/// @param {list} $values - Value for each viewport in the fluid environment. The first value will be used for the first viewport, the second value for the second viewport, and so on.
/// 
/// @return {number|string}
///
@function ig-fluid-set($values...) {
    $noop: ig-context-assert-stack-must-contain($ig-fluid-context-id, 'env');

    $data:      nth(ig-context-get($ig-fluid-context-id, 'env'), 2);
    $viewports: map-get($data, 'viewports');
    $mode:      map-get($data, 'mode');

    @if length($values) != length($viewports) {
        @error '$values must contain the same number of items as the fluid environment\'s $viewports.';
    }

    @if $mode == first {
        @return nth($values, 1);
    } @else if $mode == last {
        @return nth($values, length($values));
    } @else {
        $index:      map-get($data, 'index');
        $prev-vp:    nth($viewports, $index);
        $next-vp:    nth($viewports, $index + 1);
        $prev-value: nth($values, $index);
        $next-value: nth($values, $index + 1);

        @return ig-fluid-property-calc($prev-value, $next-value, $prev-vp, $next-vp);
    }
}

/// 
/// Generate the calc() function that uniformly scales a value from $min-value to $max-value depending
/// on the viewport width.
///
/// @param {number} $min-value - Minimum value
/// @param {number} $max-value - Maximum value
/// @param {number} $min-width - Minimum viewport width
/// @param {number} $max-width - Maximum viewport width
///
/// @access private
///
@function ig-fluid-property-calc($min-value, $max-value, $min-width, $max-width) {
    $value-unit:     unit($min-value);
    $max-value-unit: unit($max-value);
    $width-unit:     unit($min-width);
    $max-width-unit: unit($max-width);

    @if $min-value == 0 {
        $value-unit: $max-value-unit;
    }
    @if $max-value == 0 {
        $max-value-unit: $value-unit;
    }
    @if $min-width == 0 {
        $width-unit: $max-width-unit;
    }
    @if $max-width == 0 {
        $max-width-unit: $width-unit;
    }

    @if ($value-unit != $max-value-unit) or ($width-unit != $max-width-unit) {
        @error 'Units of $min-value and $max-value, $min-width and $max-width must match.';
    }

    @if ($value-unit == rem) and ($width-unit == px) {
        $min-width:  ig-px-to-rem($min-width);
        $max-width:  ig-px-to-rem($max-width);
        $width-unit: rem;
    } @else if ($value-unit == px) and ($width-unit == rem) {
        $min-value:  ig-px-to-rem($min-value);
        $max-value:  ig-px-to-rem($max-value);
        $value-unit: rem;
    }

    @if $value-unit != $width-unit {
        @error 'This combination of units is not supported.';
    }

    $value-diff: ig-strip-unit($max-value - $min-value);
    $width-diff: ig-strip-unit($max-width - $min-width);

    @return calc(#{$min-value} + #{$value-diff} * ((100vw - #{$min-width}) / #{$width-diff}));
}

@include ig-context-stack-create($ig-fluid-context-id);
