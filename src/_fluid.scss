////
/// Fluid properties.
///
/// The mixins and functions in this file allow you to scale any px- or rem-based value depending on
/// the available viewport width. One popular use case is the dynamic scaling of fonts.
///
/// The code in this file is based on an article by Niklas Postulart:
/// http://niklaspostulart.de/2015/10/sass-responsive-type-mixin
/// 
/// The following adjustments were made:
/// - Support any property passed by the user, not just font-size
/// - Allow multiple target viewports / values
/// - Provide a variant of the mixin which integrates include-media for media queries
///
/// @group Responsive
///
/// @access public
////

/// 
/// Scale a property uniformly between a specific set of target viewports / values.
///
/// @param {string} $prop      - Property to set
/// @param {number} $fluid-map - A map with keys = viewports and values = target value
///
/// @example scss - Responsive font size between 2 viewports
///   .something {
///     @include ig-fluid-property(font-size, ( 320px: 20px, 720px: 30px ));
///   }
///   
///   // Generates:
///   
///   @media (min-width: 320px) and (max-width: 720px) {
///     .something {
///       font-size: calc(20px + 10 * ((100vw - 20px) / 400));
///     }
///   }
///   
///   @media (max-width: 320px) {
///     .something {
///       font-size: 20px;
///     }
///   }
///   
///   @media (min-width: 720px) {
///     .something {
///       font-size: 30px;
///     }
///   }
///
/// @example scss - Responsive font size between 3 viewports
///   .something {
///     @include ig-fluid-property(font-size, ( 320px: 20px, 720px: 30px, 1280px: 40px ));
///   }
///   
///   // Generates:
///   
///   @media (min-width: 320px) and (max-width: 720px) {
///     .something {
///       font-size: calc(20px + 10 * ((100vw - 20px) / 400));
///     }
///   }
///   
///   @media (min-width: 720px) and (max-width: 1280px) {
///     .something {
///       font-size: calc(30px + 10 * ((100vw - 30px) / 400));
///     }
///   }
///   
///   @media (max-width: 320px) {
///     .something {
///       font-size: 20px;
///     }
///   }
///   
///   @media (min-width: 720px) {
///     .something {
///       font-size: 30px;
///     }
///   }
///
@mixin ig-fluid-property($prop, $fluid-map) {
    $keys: ig-quicksort(map-keys($fluid-map));

    @if length($keys) <= 1 {
        @error '$fluid-map must contain at least two viewports.';
    }

    @for $i from 1 to length($keys) {
        $prev-key: nth($keys, $i);
        $next-key: nth($keys, $i + 1);

        $prev-value: map-get($fluid-map, $prev-key);
        $next-value: map-get($fluid-map, $next-key);

        $calc: ig-fluid-property-calc($prev-value, $next-value, $prev-key, $next-key);

        @media (min-width: $prev-key) and (max-width: $next-key) {
            #{$prop}: $calc;
        }
    }

    $first-key: nth($keys, 1);
    $last-key:  nth($keys, length($keys));

    @media (max-width: $first-key) {
        #{$prop}: map-get($fluid-map, $first-key);
    }

    @media (min-width: $last-key) {
        #{$prop}: map-get($fluid-map, $last-key);
    }
}

/// 
/// Version of ig-fluid-property that supports include-media viewports in the $fluid-map.
///
/// @see {mixin} ig-fluid-property
/// 
@mixin ig-fluid-property-im($prop, $fluid-map) {
    $new-map: ();

    @each $key, $value in $fluid-map {
        @if map-has-key($breakpoints, $key) {
            $key: map-get($breakpoints, $key);
        }

        $new-map: map-merge($new-map, ($key: $value));
    }

    @include ig-fluid-property($prop, $new-map);
}

/// 
/// Generate the calc() function that uniformly scales a value from $min-value to $max-value depending
/// on the viewport width.
///
/// @param {number} $min-value - Minimum value
/// @param {number} $max-value - Maximum value
/// @param {number} $min-width - Minimum viewport width
/// @param {number} $max-width - Maximum viewport width
///
/// @access private
///
@function ig-fluid-property-calc($min-value, $max-value, $min-width, $max-width) {
    $value-unit:     unit($min-value);
    $max-value-unit: unit($max-value);
    $width-unit:     unit($min-width);
    $max-width-unit: unit($max-width);

    @if $min-value == 0 {
        $value-unit: $max-value-unit;
    }
    @if $max-value == 0 {
        $max-value-unit: $value-unit;
    }
    @if $min-width == 0 {
        $width-unit: $max-width-unit;
    }
    @if $max-width == 0 {
        $max-width-unit: $width-unit;
    }

    @if ($value-unit != $max-value-unit) or ($width-unit != $max-width-unit) {
        @error 'Units of $min-value and $max-value, $min-width and $max-width must match.';
    }

    @if ($value-unit == rem) and ($width-unit == px) {
        $min-width:  ig-px-to-rem($min-width);
        $max-width:  ig-px-to-rem($max-width);
        $width-unit: rem;
    } @else if ($value-unit == px) and ($width-unit == rem) {
        $min-value:  ig-px-to-rem($min-value);
        $max-value:  ig-px-to-rem($max-value);
        $value-unit: rem;
    }

    @if $value-unit != $width-unit {
        @error 'This combination of units is not supported.';
    }

    $value-diff: ig-strip-unit($max-value - $min-value);
    $width-diff: ig-strip-unit($max-width - $min-width);

    @return calc(#{$min-value} + #{$value-diff} * ((100vw - #{$min-width}) / #{$width-diff}));
}