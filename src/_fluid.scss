////
/// Fluid properties.
///
/// The mixins and functions in this file allow you to scale any px- or rem-based value depending on
/// the available viewport width. One popular use case is the dynamic scaling of fonts.
///
/// The code in this file is based on an article by Niklas Postulart:
/// http://niklaspostulart.de/2015/10/sass-responsive-type-mixin
/// 
/// The following adjustments were made:
/// - Support any property passed by the user, not just font-size
/// - Allow multiple target viewports / values
/// - Provide a variant of the mixin which integrates include-media for media queries
///
/// @group Responsive
///
/// @access public
////

///
/// If true, named viewports will be supported if a compatible $breakpoints map exists.
/// This is the case for [include-media](https://include-media.com/), for example.
///
/// @type bool
///
$ig-fluid-support-named-viewports: true !default;

/// 
/// Scale a property uniformly between a specific set of target viewports / values.
///
/// @param {string | list} $props     - Property or list of properties to set
/// @param {number}        $fluid-map - A map with keys = viewports and values = target value
///
/// @example scss - Responsive font-size between 2 viewports
///   .something {
///     @include ig-fluid-property(font-size, ( 320px: 20px, 720px: 30px ));
///   }
///   
///   // Generates:
///   
///   @media (min-width: 320px) and (max-width: 720px) {
///     .something {
///       font-size: calc(20px + 10 * ((100vw - 20px) / 400));
///     }
///   }
///   
///   @media (max-width: 320px) {
///     .something {
///       font-size: 20px;
///     }
///   }
///   
///   @media (min-width: 720px) {
///     .something {
///       font-size: 30px;
///     }
///   }
///
/// @example scss - Responsive font-size between 3 viewports
///   .something {
///     @include ig-fluid-property(font-size, ( 320px: 20px, 720px: 30px, 1280px: 40px ));
///   }
///   
///   // Generates:
///   
///   @media (min-width: 320px) and (max-width: 720px) {
///     .something {
///       font-size: calc(20px + 10 * ((100vw - 20px) / 400));
///     }
///   }
///   
///   @media (min-width: 720px) and (max-width: 1280px) {
///     .something {
///       font-size: calc(30px + 10 * ((100vw - 30px) / 400));
///     }
///   }
///   
///   @media (max-width: 320px) {
///     .something {
///       font-size: 20px;
///     }
///   }
///   
///   @media (min-width: 720px) {
///     .something {
///       font-size: 30px;
///     }
///   }
///
@mixin ig-fluid-property($props, $fluid-map) {
    @if length($fluid-map) <= 1 {
        @error '$fluid-map must contain at least two viewports.';
    }

    $new-fluid-map: ();

    @each $key, $value in $fluid-map {
        @if $ig-fluid-support-named-viewports and global-variable-exists(breakpoints) {
            @if map-has-key($breakpoints, $key) {
                $key: map-get($breakpoints, $key);
            }
        }

        @if (type-of($key) != number) or unitless($key) {
            @error '$fluid-map contains invalid viewports.';
        }

        $new-fluid-map: map-merge($new-fluid-map, ($key: $value));
    }

    $fluid-map: $new-fluid-map;
    $keys:      ig-quicksort(map-keys($fluid-map));

    @for $i from 1 to length($keys) {
        $prev-key: nth($keys, $i);
        $next-key: nth($keys, $i + 1);

        $prev-value: map-get($fluid-map, $prev-key);
        $next-value: map-get($fluid-map, $next-key);

        $calc: ig-fluid-property-calc($prev-value, $next-value, $prev-key, $next-key);

        @media (min-width: $prev-key) and (max-width: $next-key) {
            @if type-of($props) == list {
                @each $prop in $props {
                    #{$prop}: $calc;
                }
            } @else {
                #{$props}: $calc;
            }
        }
    }

    $first-key: nth($keys, 1);
    $last-key:  nth($keys, length($keys));

    @media (max-width: $first-key) {
        $val: map-get($fluid-map, $first-key);

        @if type-of($props) == list {
            @each $prop in $props {
                #{$prop}: $val;
            }
        } @else {
            #{$props}: $val;
        }
    }

    @media (min-width: $last-key) {
        $val: map-get($fluid-map, $last-key);

        @if type-of($props) == list {
            @each $prop in $props {
                #{$prop}: $val;
            }
        } @else {
            #{$props}: $val;
        }
    }
}

/// 
/// Generate the calc() function that uniformly scales a value from $min-value to $max-value depending
/// on the viewport width.
///
/// @param {number} $min-value - Minimum value
/// @param {number} $max-value - Maximum value
/// @param {number} $min-width - Minimum viewport width
/// @param {number} $max-width - Maximum viewport width
///
/// @access private
///
@function ig-fluid-property-calc($min-value, $max-value, $min-width, $max-width) {
    $value-unit:     unit($min-value);
    $max-value-unit: unit($max-value);
    $width-unit:     unit($min-width);
    $max-width-unit: unit($max-width);

    @if $min-value == 0 {
        $value-unit: $max-value-unit;
    }
    @if $max-value == 0 {
        $max-value-unit: $value-unit;
    }
    @if $min-width == 0 {
        $width-unit: $max-width-unit;
    }
    @if $max-width == 0 {
        $max-width-unit: $width-unit;
    }

    @if ($value-unit != $max-value-unit) or ($width-unit != $max-width-unit) {
        @error 'Units of $min-value and $max-value, $min-width and $max-width must match.';
    }

    @if ($value-unit == rem) and ($width-unit == px) {
        $min-width:  ig-px-to-rem($min-width);
        $max-width:  ig-px-to-rem($max-width);
        $width-unit: rem;
    } @else if ($value-unit == px) and ($width-unit == rem) {
        $min-value:  ig-px-to-rem($min-value);
        $max-value:  ig-px-to-rem($max-value);
        $value-unit: rem;
    }

    @if $value-unit != $width-unit {
        @error 'This combination of units is not supported.';
    }

    $value-diff: ig-strip-unit($max-value - $min-value);
    $width-diff: ig-strip-unit($max-width - $min-width);

    @return calc(#{$min-value} + #{$value-diff} * ((100vw - #{$min-width}) / #{$width-diff}));
}
