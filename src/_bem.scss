////
/// BEM.
///
/// BEM is a methodology for structuring websites and is mostly known for it's CSS naming convention.
/// BEMIT is in extension of this methodology and allows you to give blocks a more fine-grained  purpose
/// than BEM alone would let you do.
///
/// SASS does support BEM quite well thanks to the ampersand (&) and the @at-root directive. However,
/// there is no way to make sure users adhere to the BEM or BEMIT methodology.
/// That's where the mixins in this file come into play: They automatically generate the right selectors
/// and perform checks regarding the nesting order, nesting depth, and so on.
///
/// There are comments in the mixins explaining what selector is generated. The EBNF grammar is as follows:
///
///   (* Shorthands for block, element, modifier, suffix, theme *)
///   entity_shorthand = "b" "e" "m" "s" "t" ;
///   
///   (* One or multiple BEMIT entities that were generated with an earlier mixin invocation *)
///   existing_entities = "{" entity_shorthand { "," entity_shorthand } "}" ;
///   
///   (* A BEM entity that doesn't depend on a parent entity *)
///   generated_independent_entity = "block" | "theme" ;
///   
///   (* A BEM entity that is attached to a parent entity *)
///   generated_attached_entity = existing_entities ( "__element" | "--modifier" | "@suffix" ) ;
///   
///   (* A selector created by the user, such as "&:hover", "> a", and so on *)
///   manual_selector_part = "[manual selector]" ;
///   
///   (* A part of the selector that may or may not be in the generated result *)
///   optional_selector_part = "(" ( existing_entities | manual_selector_part ) ")" ;
///   
///   (* One part of the selector *)
///   selector_part = existing_entities | manual_selector_part | optional_selector_part | generated_independent_entity | generated_attached_entity ;
///   
///   (* The whole selector *)
///   selector = selector_part { ( " " | "." ) selector_part } ;
///
/// @link https://en.bem.info/                                                                   Information about BEM
/// @link https://csswizardry.com/2015/08/bemit-taking-the-bem-naming-convention-a-step-further/ Information about BEMIT 
///
/// @group BEM
///
/// @access public
////

///
/// Character sequence for BEM elements.
///
/// @type string
///
$ig-bem-element-separator: '__' !default;

///
/// Character sequence for BEM modifiers.
///
/// @type string
///
$ig-bem-modifier-separator: '--' !default;

///
/// Character sequence for BEMIT suffixes.
///
/// @type string
///
$ig-bem-suffix-separator: '\\@' !default;

///
/// Prefixes for all BEMIT namespaces.
///
/// @prop {string} utility   ['u'] - Utility namespace
/// @prop {string} object    ['o'] - Object namespace
/// @prop {string} component ['c'] - Component namespace
/// @prop {string} layout    ['l'] - Layout namespace
/// @prop {string} scope     ['s'] - Scope namespace
/// @prop {string} theme     ['t'] - Theme namespace
///
/// @type map
///
$ig-bem-namespaces: (
    utility:   'u',
    object:    'o',
    component: 'c',
    layout:    'l',
    scope:     's',
    theme:     't',
    js:        'js',
    qa:        'qa',
    hack:      '_'
) !default;

///
/// A list of all generated BEMIT blocks. 
///
/// @type list
///
/// @access private
///
$ig-bem-blocks: ();

///
/// Maximum nesting depth of BEM mixins. The large default value means there is no effective limit.
/// 
/// @type number
///
$ig-bem-max-depth: 99 !default;

///
/// Indicates if nesting elements is allowed.
/// Related elements are excluded from this option.
/// 
/// @type bool
///
$ig-bem-allow-nested-elements: true !default;

///
/// Context ID used for all BEM-related mixins.
///
/// @type string
///
$ig-bem-context-id: 'bem' !default;

/// 
/// Generate a new BEMIT block.
///
/// This mixin simply creates a new block with the name {namespace}_{name},
/// where {namespace} is the prefix assigned to $type and {name} is the
/// block's name.
///
/// @param {string} $name        - Block name
/// @param {string} $type [null] - BEMIT namespace of the block
///
/// @content [All declarations belonging to that block]
///
/// @throw If $type is invalid
/// @throw If the block is preceded by another block, element, modifier, suffix or theme
///
/// @example scss - Creating a new block
///   @include ig-bem-block('something', 'component') {
///     /* some definitions */
///   }
///   
///   // Generates:
///   
///   .c-something {
///     /* some definitions */
///   }
///
@mixin ig-bem-block($name, $type: null) {
    //
    // Blocks can only be used by itself or within a theme.
    // Possible outcomes:
    //   - ({t}) block
    //

    @include ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    @include ig-context-assert-stack-must-not-contain($ig-bem-context-id, 'block' 'element' 'modifier' 'suffix');

    $selector: null;

    @if $type != null {
        $namespace: map-get($ig-bem-namespaces, $type);

        @if not $namespace {
            @error '"#{$type}" is not a valid type.';
        }

        $selector: selector-parse('.' + $namespace + '-' + $name);
    } @else {
        $selector: selector-parse('.' + $name);
    }

    $parent-context: ig-context-get($ig-bem-context-id, 'theme');

    @if $parent-context != null {
        //
        // Block is used within a theme.
        // Make sure there are no selectors between theme and this mixin call.
        //

        $parent-selector: map-get(nth($parent-context, 2), 'selector');

        @if not is-superselector(&, $parent-selector) {
            @error 'Block must be an immediate child of the theme.';
        }

        $selector: selector-nest(&, $selector);
        $selector: ig-selector-nest-fix($selector);
    } @else if & {
        @error 'Block must be declared at the root level.';
    }

    $ig-bem-blocks: append($ig-bem-blocks, $name + if($type != null, '_' + $type, '')) !global;

    @include ig-context-push($ig-bem-context-id, 'block', ('name': $name, 'selector': $selector));
    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

/// 
/// Generate a new BEMIT object block. It's a shorthand for ig-bem-block($name, 'object').
///
/// @param {string} $name - Object block name
///
/// @content [All declarations belonging to that object block]
///
@mixin ig-bem-object($name) {
    @include ig-bem-block($name, 'object') {
        @content;
    }
}

/// 
/// Generate a new BEMIT component block. It's a shorthand for ig-bem-block($name, 'component').
///
/// @param {string} $name - Component block name
///
/// @content [All declarations belonging to that component block]
///
@mixin ig-bem-component($name) {
    @include ig-bem-block($name, 'component') {
        @content;
    }
}

/// 
/// Generate a new BEMIT layout block. It's a shorthand for ig-bem-block($name, 'layout').
///
/// @param {string} $name - Layout block name
///
/// @content [All declarations belonging to that layout block]
///
@mixin ig-bem-layout($name) {
    @include ig-bem-block($name, 'layout') {
        @content;
    }
}

/// 
/// Generate a new BEMIT utility block. It's a shorthand for ig-bem-block($name, 'utility').
///
/// @param {string} $name - Utility block name
///
/// @content [All declarations belonging to that utility block]
///
@mixin ig-bem-utility($name) {
    @include ig-bem-block($name, 'utility') {
        @content;
    }
}

/// 
/// Generate a new BEMIT scope block. It's a shorthand for ig-bem-block($name, 'scope').
///
/// @param {string} $name - Scope block name
///
/// @content [All declarations belonging to that scope block]
///
@mixin ig-bem-scope($name) {
    @include ig-bem-block($name, 'scope') {
        @content;
    }
}

/// 
/// Generate a new BEMIT JS block. It's a shorthand for ig-bem-block($name, 'js').
///
/// @param {string} $name - JS block name
///
/// @content [All declarations belonging to that JS block]
///
@mixin ig-bem-js($name) {
    @include ig-bem-block($name, 'js') {
        @content;
    }
}

/// 
/// Generate a new BEMIT QA block. It's a shorthand for ig-bem-block($name, 'qa').
///
/// @param {string} $name - QA block name
///
/// @content [All declarations belonging to that QA block]
///
@mixin ig-bem-qa($name) {
    @include ig-bem-block($name, 'qa') {
        @content;
    }
}

/// 
/// Generate a new BEMIT hack block. It's a shorthand for ig-bem-block($name, 'hack').
///
/// @param {string} $name - Hack block name
///
/// @content [All declarations belonging to that hack block]
///
@mixin ig-bem-hack($name) {
    @include ig-bem-block($name, 'hack') {
        @content;
    }
}

/// 
/// Assert that a block or element is composed of another block. In BEM, such a relationship is referred to
/// as a "mix": https://en.bem.info/methodology/key-concepts/#mix
///
/// Compilation will fail if the foreign block doesn't exist. This way, you can ensure that blocks are
/// defined in the right order so that composed blocks/elements will actually override the foreign
/// declarations without having to artificially increase the specificity.
///
/// @param {string} $name - Block name
/// @param {string} $type - BEMIT namespace of the block
///
/// @throw If $type is invalid 
/// @throw If the block doesn't exist
///
/// @example scss - Successful assertion
///   @include ig-bem-component('someBlock') {
///     /* some definitions */
///   }
///   
///   @include ig-bem-component('anotherBlock') {
///     /* some definitions */
///     
///     @include ig-bem-element('elem') {
///       @include ig-bem-composed-of('someBlock', 'component');
///       
///       /* some definitions */
///     }
///   }
///
///   // Intended use: <div class="c-anotherBlock__elem c-someBlock">...</div>
///
/// @example scss - Failing assertion
///   @include ig-bem-component('anotherBlock') {
///     /* some definitions */
///     
///     @include ig-bem-element('elem') {
///       @include ig-bem-composed-of('someBlock', 'component');
///       
///       /* some definitions */
///     }
///   }
///   
///   @include ig-bem-component('someBlock') {
///     /* some definitions */
///   }
///   
///   // Compilation will fail because c-someBlock is defined after c-anotherBlock__elem
///
@mixin ig-bem-composed-of($name, $type: null) {
    @if $type != null and not map-get($ig-bem-namespaces, $type) {
        @error '"#{$type}" is not a valid type.';
    }

    @if not index($ig-bem-blocks, $name + if($type != null, '_' + $type, '')) {
        @error 'Block "#{$name}" does not exist.';
    }
}

/// 
/// Generate a new BEM element.
///
/// The element will be generated according to the BEM naming convention.
/// If the parent selector doesn't match the block selector, the element will be
/// nested inside the parent selector. This means, you may nest elements inside
/// other elements, modifiers or any kind of selector such as &:hover.
///
/// @param {string} $name - Element name
///
/// @content [All declarations belonging to that element]
///
/// @throw If the element is not preceded by a block, element, modifier or suffix.
///
/// @example scss - Element for a block
///   @include ig-bem-component('block') {
///     /* some block definitions */
///     
///     @include ig-bem-element('elem') {
///       /* some element definitions */
///     }
///   }
///   
///   // Generates:
///   
///   .c-block {
///     /* some block definitions */
///   }
///   
///   .c-block__elem {
///     /* some element definitions */
///   }
///
/// @example scss - Element that is affected by the user hovering the block
///   @include ig-bem-component('block') {
///     /* some block definitions */
///     
///     @include ig-bem-element('elem') {
///       background-color: #eee;
///     }
///     
///     &:hover {
///       @include ig-bem-element('elem') {
///         background-color: #000;
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block {
///     /* some block definitions */
///   }
///   
///   .c-block__elem {
///     background-color: #eee;
///   }
///   
///   .c-block:hover .c-block__elem {
///     background-color: #000;
///   }
///
/// @example scss - Multiple elements
///   @include ig-bem-component('block') {
///     /* some block definitions */
///     
///     @include ig-bem-element('elem1', 'elem2') {
///       /* some element definitions */
///     }
///   }
///   
///   // Generates:
///   
///   .c-block {
///     /* some block definitions */
///   }
///   
///   .c-block__elem1, .c-block__elem2 {
///     /* some element definitions */
///   }
///
@mixin ig-bem-element($name, $names...) {
    @include ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    @include ig-context-assert-stack-must-contain($ig-bem-context-id, 'block');

    @if not $ig-bem-allow-nested-elements {
        //
        // Element nesting was forbidden by the user
        //

        @include ig-context-assert-stack-must-not-contain($ig-bem-context-id, 'element');
    }

    $selector:   ();
    $parts-data: ();

    @each $name in join($name, $names) {
        $sel:            null;
        $parent-context: ig-context-get($ig-bem-context-id, 'block' 'element' 'modifier' 'suffix' 'theme');

        @if index('element' 'modifier' 'suffix', nth($parent-context, 1)) {
            //
            // Parent context is element, modifier or suffix.
            // Possible outcomes:
            //   - {e,m,s} ([manual selector]) {b}__element
            //

            $block-context:  ig-context-get($ig-bem-context-id, 'block');
            $block-selector: map-get(nth($block-context, 2), 'selector');

            $sel: selector-nest(&, selector-append($block-selector, $ig-bem-element-separator + $name));
            $sel: ig-selector-nest-fix($sel);
        } @else {
            //
            // Parent context is block or theme.
            //

            $parent-selector: map-get(nth($parent-context, 2), 'selector');

            @if is-superselector(&, $parent-selector) {
                //
                // The current selector matches the parent selector.
                // The element part can simply be appended.
                // Possible outcomes:
                //   - {b}__element
                //

                $sel: selector-append(&, $ig-bem-element-separator + $name);
            } @else {
                //
                // The current selector doesn't match the parent selector.
                // The user manually added a selector between parent context and this mixin call.
                // Possible outcomes:
                //   - {b} [manual selector] {b}__element
                //

                @if nth($parent-context, 1) == 'theme' {
                    $block-context:  ig-context-get($ig-bem-context-id, 'block');
                    $parent-selector: map-get(nth($block-context, 2), 'selector');
                }

                $sel: selector-nest(&, selector-append($parent-selector, $ig-bem-element-separator + $name));
                $sel: ig-selector-nest-fix($sel);
            }
        }

        $selector:   join($selector, $sel, 'comma');
        $parts-data: append($parts-data, ('name': $name, 'selector': $sel));
    }

    @include ig-context-push($ig-bem-context-id, 'element', (
            'parts':    $parts-data,
            'selector': $selector
    ));
    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

/// 
/// Generate a BEM element that is related to the current element.
///
/// The generated element selector is appended to the current element selector. The $sign
/// determines the relationship.
///
/// @param {string} $name - Element name
/// @param {string} $sign - Relationshop sign, either '+' or '~'
///
/// @content [All declarations belonging to that element]
///
/// @throw If the element is not preceded by an element.
///
/// @example scss - A sibling element to a single element
///   @include ig-bem-component('block') {
///     @include ig-bem-element('elem') {
///       /* some element definitions */
///       
///       @include ig-bem-related-element('~', 'sibling') {
///         /* some sibling element definitions */
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block__elem {
///     /* some element definitions */
///   }
///   
///   .c-block__elem ~ .c-block__sibling {
///     /* some sibling element definitions */
///   }
///
/// @example scss - A successor element to a single element
///   @include ig-bem-component('block') {
///     @include ig-bem-element('elem') {
///       /* some element definitions */
///       
///       @include ig-bem-related-element('+', 'successor') {
///         /* some successor element definitions */
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block__elem {
///     /* some element definitions */
///   }
///   
///   .c-block__elem + .c-block__successor {
///     /* some successor element definitions */
///   }
///
/// @example scss - A successor element to multiple elements
///   @include ig-bem-component('block') {
///     @include ig-bem-element('elem1', 'elem2') {
///       /* some element definitions */
///       
///       @include ig-bem-related-element('+', 'successor') {
///         /* some successor element definitions */
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block__elem1, .c-block__elem2 {
///     /* some element definitions */
///   }
///   
///   .c-block__elem1 + .c-block__successor, .c-block__elem2 + .c-block__successor {
///     /* some successor element definitions */
///   }
///
@mixin ig-bem-related-element($sign, $name, $names...) {
    //
    // Generating this selector is simple: Take the latest block context, use it
    // to generate the element part, and insert it at the end of the current selector.
    // Possible outcomes:
    //   - {e} ({m,s}) ([manual selector]) + {e}
    //   - {e} ({m,s}) ([manual selector]) ~ {e}
    //

    @include ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    @include ig-context-assert-stack-must-contain($ig-bem-context-id, 'element');

    @if $sign != '+' and $sign != '~' {
        @error 'Invalid relationship sign #{inspect($sign)}.';
    }

    $block-context:  ig-context-get($ig-bem-context-id, 'block');
    $block-selector: map-get(nth($block-context, 2), 'selector');

    $selector:   ();
    $parts-data: ();

    @each $name in join($name, $names) {
        $sel: selector-nest(&, $sign, selector-append($block-selector, $ig-bem-element-separator + $name));
        $sel: ig-selector-nest-fix($sel);

        $selector:   join($selector, $sel, 'comma');
        $parts-data: append($parts-data, ('name': $name, 'selector': $sel));
    }

    @include ig-context-push($ig-bem-context-id, 'element', (
            'parts':    $parts-data,
            'selector': $selector
    ));
    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

/// 
/// Generate a BEM element that is a sibling of the current element.
///
/// It's a shorthand for ig-bem-related-element('~', $name).
///
/// @param {string} $name - Element name
///
/// @content [All declarations belonging to that element]
///
@mixin ig-bem-sibling-element($name, $names...) {
    @include ig-bem-related-element('~', $name, $names...) {
        @content;
    }
}

/// 
/// Generate a BEM element that is the successor of the current element.
///
/// It's a shorthand for ig-bem-related-element('+', $name).
///
/// @param {string} $name - Element name
///
/// @content [All declarations belonging to that element]
///
@mixin ig-bem-next-element($name, $names...) {
    @include ig-bem-related-element('+', $name, $names...) {
        @content;
    }
}

/// 
/// Generate the current BEM element as a successor of itself.
///
/// If this is applied to a single element, it behaves exactly the same as
/// ig-bem-related-element('+', name);
/// However, if it is applied to multiple elements, each twin element only will influence
/// their other twin, which is not replicable with ig-bem-related-element.
///
/// @content [All declarations belonging to that element]
///
/// @example scss - Two twin elements
///   @include ig-bem-component('block') {
///     @include ig-bem-element('elem') {
///       /* some element definitions */
///       
///       @include ig-bem-next-twin-element {
///         /* some twin element definitions */
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block__elem {
///     /* some element definitions */
///   }
///   
///   .c-block__elem + .c-block__elem {
///     /* some twin element definitions */
///   }
///
/// @example scss - Multiple twin elements
///   @include ig-bem-component('block') {
///     @include ig-bem-element('elem1', 'elem2') {
///       /* some element definitions */
///       
///       @include ig-bem-next-twin-element {
///         /* some twin element definitions */
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block__elem1, .c-block__elem2 {
///     /* some element definitions */
///   }
///   
///   .c-block__elem1 + .c-block__elem1, .c-block__elem2 + .c-block__elem2 {
///     /* some twin element definitions */
///   }
///
@mixin ig-bem-next-twin-element {
    @include ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    @include ig-context-assert-stack-must-contain($ig-bem-context-id, 'element');

    $element-context: ig-context-get($ig-bem-context-id, 'element');

    $block-context:  ig-context-get($ig-bem-context-id, 'block');
    $block-selector: map-get(nth($block-context, 2), 'selector');

    $selector:   ();
    $parts-data: ();

    //
    // To determine the twin for each element, iterate the parts from the latest element
    // context.
    // Then, iterate all sub-selectors from the current selector and check if it contains
    // the element part selector. This has to be done with string comparison since none of
    // SASS selector functions would be useful here. 
    // Finally, the current twin will be appended to the extracted selector part as a successor
    // element.
    // Possible outcomes:
    //   - {e} ({m,s}) ([manual selector]) + {e}
    //
    @each $part-data in map-get(nth($element-context, 2), 'parts') {
        $part-selector: map-get($part-data, 'selector');
        $part-name:     map-get($part-data, 'name');

        $current-selector-part: null;
        @each $s in & {
            @if str-index(inspect($s), inspect($part-selector)) {
                $current-selector-part: $s;
            }
        }
        @if $current-selector-part == null {
            @error 'Could not generate twin element selector.';
        }

        $sel: selector-nest($current-selector-part, '+', selector-append($block-selector, $ig-bem-element-separator + $part-name));

        $selector:   join($selector, $sel, 'comma');
        $parts-data: append($parts-data, ('name': $part-name, 'selector': $sel));
    }

    @include ig-context-push($ig-bem-context-id, 'element', (
            'parts':    $parts-data,
            'selector': $selector
    ));
    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

/// 
/// Generate a new BEM modifier.
/// 
/// If the parent context is block or element, the modifier will modify said block or element according
/// to the BEM naming convention.
///
/// If the parent context is a modifier or suffix, then the modifier will depend on said modifier or suffix.
/// Depending on $extend, the meaning of this dependency (and the resulting selector) varies:
/// If it's false (default), you signalize that the modifier also exists by itself, but it changes its
/// behavior when the parent modifier or suffix is set.
/// If it's true, you signalize that the modifier extends the parent modifier or suffix and can only be
/// used in conjunction with it.
///
/// @param {string} $name           - Modifier name
/// @param {bool}   $extend [false] - Indicate if the parent modifier or suffix will be extended
///
/// @content [All declarations belonging to that modifier]
///
/// @throw If the element is not preceded by a block, element, modifier, suffix or theme.
///
/// @example scss - Modifier that modifies a block or element
///   @include ig-bem-component('block') {
///     @include ig-bem-modifier('mod') {
///       background-color: #eee;
///     }
///     
///     @include ig-bem-element('elem') {
///       @include ig-bem-modifier('mod') {
///         background-color: #222;
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block--mod {
///     background-color: #eee;
///   }
///   
///   .c-block__elem--mod {
///     background-color: #222;
///   }
///
/// @example scss - Modifier nested in another modifier, not extending
///   @include ig-bem-component('block') {
///     @include ig-bem-modifier('mod') {
///       background-color: #eee;
///     }
///     
///     @include ig-bem-modifier('dark') {
///       /* some definitions */
///       
///       @include ig-bem-modifier('mod') {
///         background-color: #222;
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block--mod {
///     background-color: #eee;
///   }
///   
///   .c-block--dark {
///     /* some definitions */
///   }
///   
///   .c-block--dark.c-block--mod {
///     background-color: #222;
///   }
///
/// @example scss - Modifier nested in another modifier, extending
///   @include ig-bem-component('block') {
///     @include ig-bem-modifier('mod') {
///       background-color: #eee;
///     }
///     
///     @include ig-bem-modifier('dark') {
///       /* some definitions */
///       
///       @include ig-bem-modifier('mod', true) {
///         background-color: #222;
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block--mod {
///     background-color: #eee;
///   }
///   
///   .c-block--dark {
///     /* some definitions */
///   }
///   
///   .c-block--dark--mod {
///     background-color: #222;
///   }
///
@mixin ig-bem-modifier($name, $extend: false) {
    @include ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    @include ig-context-assert-stack-must-contain($ig-bem-context-id, 'block');

    $parent-context: ig-context-get($ig-bem-context-id, 'block' 'element' 'modifier' 'suffix' 'theme');
    $selector:       null;

    @if index('block' 'element' 'theme', nth($parent-context, 1)) or $extend == true {
        //
        // Either the parent context is block, element or theme, or a modifier or suffix
        // is to be extended.
        //

        $parent-selector: map-get(nth($parent-context, 2), 'selector');

        @if not is-superselector(&, $parent-selector) {
            //
            // The current selector doesn't match the parent selector.
            // The user manually added a selector between parent context and this modifier call.
            // This case is forbidden because any outcome semantically wouldn't make sense:
            //   - {b,e,m,s} [manual selector] {b,e,m,s}--modifier
            //   - {b,e,m,s}--modifier [manual selector]
            // The first case would make the modifier behave like an element.
            // The second case is unintuitive, the code would be more clear by nesting the manual
            // selector in the modifier instead.
            //

            @error 'A modifier must be an immediate child of the parent context';
        }

        //
        // The modifier part can simply be appended.
        // Possible outcomes:
        //   - {b,e,m,s}--modifier
        //

        $selector: selector-append(&, $ig-bem-modifier-separator + $name);
    } @else {
        //
        // Parent context is modifier or suffix and $extend is false.
        // Possible outcomes:
        //   - {m,s}.{b,e}--modifier
        //

        $parent-context:  ig-context-get($ig-bem-context-id, 'block' 'element');
        $parent-selector: map-get(nth($parent-context, 2), 'selector');

        $selector: selector-append(&, $parent-selector, $ig-bem-modifier-separator + $name);
    }

    @include ig-context-push($ig-bem-context-id, 'modifier', ('name': $name, 'selector': $selector));
    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

/// 
/// Generate a new BEMIT suffix.
///
/// @param {string} $name - Suffix name
///
/// @content [All declarations belonging to that suffix]
///
/// @throw If the element is not preceded by a block, modifier or theme.
///
/// @example scss - Using a suffix
///   @include ig-bem-utility('hidden') {
///     display: none;
///     
///     @media (max-width: 320px) {
///       @include ig-bem-suffix('phone') {
///         display: none;
///       }
///     }
///     
///     @media (max-width: 768px) {
///       @include ig-bem-suffix('tablet') {
///         display: none;
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .u-hidden {
///     display: none;
///   }
///   
///   @media (max-width: 320px) {
///     .u-hidden@phone {
///       display: none;
///     }
///   }
///   
///   @media (max-width: 768px) {
///     .u-hidden@tablet {
///       display: none;
///     }
///   }
///
@mixin ig-bem-suffix($name) {
    //
    // Suffixes can be used on block, element, modifier and theme.
    //

    @include ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    @include ig-context-assert-stack-must-contain($ig-bem-context-id, 'block');
    @include ig-context-assert-stack-must-not-contain($ig-bem-context-id, 'suffix');

    $parent-context:  ig-context-get($ig-bem-context-id, 'block' 'element' 'modifier' 'theme');
    $parent-selector: map-get(nth($parent-context, 2), 'selector');

    @if not is-superselector(&, $parent-selector) {
        //
        // The current selector doesn't match the parent selector.
        // The user manually added a selector between parent context and this suffix call.
        // This case is forbidden because any outcome semantically wouldn't make sense:
        //   - {b,e,m} [manual selector] {b,e,m}@suffix
        //   - {b,e,m}@suffix [manual selector]
        // The first case would make the modifier behave like an element.
        // The second case is unintuitive, the code would be more clear by nesting the manual
        // selector in the suffix instead.
        //

        @error 'A suffix must be an immediate child of the parent context';
    }

    //
    // The suffix part can simply be appended.
    // Possible outcomes:
    //   - {b,e,m}@suffix
    //

    $selector: selector-append(&, $ig-bem-suffix-separator + $name);

    @include ig-context-push($ig-bem-context-id, 'suffix', ('name': $name, 'selector': $selector));
    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

/// 
/// Generate a new BEMIT theme.
///
/// The way themes work is a bit more complicated than described in the article about BEMIT. If you nest
/// themes in the DOM, it needs to be guaranteed that always the definitions in the latest theme take precedence.
/// To achieve this, the generated selector looks as follows: .t-theme, [class*=" t-"] .t-theme
/// Unfortunately, this only covers the case that two themes are nested as the number of matched elements
/// with [class*=" t-"] doesn't increase the importance of the style definitions. However, I have yet to run into
/// any problems.
///
/// @param {string} $name             - Theme name
/// @param {string} $sub-theme [null] - If set to a non-null value, this mixin generates a theme that modifies the original theme $name.
///
/// @content [All declarations belonging to that theme]
///
/// @throw If the element is preceded by another theme.
///
/// @example scss - Modifier that modifies a block or element
///   @include ig-bem-component('block') {
///     background-color: #eee;
///     
///     @include ig-bem-theme('dark') {
///       background-color: #222;
///     }
///   }
///   
///   // Generates:
///   
///   .c-block {
///     background-color: #eee;
///   }
///   
///   .t-dark .c-block, [class*=" t-"] .t-dark .c-block {
///     background-color: #222;
///   }
///
@mixin ig-bem-theme($theme, $sub-theme: null) {
    //
    // Themes can only be used by itself or as immediate child of a block.
    // Possible outcomes:
    //   - theme ({b})
    //

    @include ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    @include ig-context-assert-stack-must-not-contain($ig-bem-context-id, 'element' 'modifier' 'suffix' 'theme');

    $parent-context: ig-context-get($ig-bem-context-id, 'block');
    $selector:       ig-bem-theme-selector($theme, $sub-theme);

    @if $parent-context != null {
        //
        // Theme is used within a block.
        // Make sure there are no selectors between block and this mixin call.
        //

        $parent-selector: map-get(nth($parent-context, 2), 'selector');

        @if not is-superselector(&, $parent-selector) {
            @error 'Theme must be an immediate child of the block.';
        }

        $selector: selector-nest($selector, &);
        $selector: ig-selector-nest-fix($selector);
    } @else if & {
        @error 'Theme must be declared at the root level.';
    }

    @include ig-context-push($ig-bem-context-id, 'theme', ('selector': $selector));
    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

/// 
/// Generate the selector for a BEMIT theme.
///
/// @param {string} $name             - Theme name
/// @param {string} $sub-theme [null] - If set to a non-null value, this function generates a theme selector that modifies the original theme $name
///
/// @access private
///
@function ig-bem-theme-selector($name, $sub-theme: null) {
    $namespace:      map-get($ig-bem-namespaces, 'theme') + '-';
    $theme-selector: '.' + $namespace + $name;
    $selector:       selector-parse('#{$theme-selector}, [class*=" t-"] #{$theme-selector}');

    @if $sub-theme != null {
        $sub-theme-selector: '.' + $namespace + $sub-theme;
        $selector:           selector-parse('#{$theme-selector} #{$sub-theme-selector}, #{$theme-selector}#{$sub-theme-selector}');
    }

    @return $selector;
}

//

@include ig-context-stack-create($ig-bem-context-id);
