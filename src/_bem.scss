////
/// BEM.
///
/// BEM is a methodology for structuring websites and is mostly known for it's CSS naming convention.
/// BEMIT is in extension of this methodology and allows you to give blocks a more fine-grained  purpose
/// than BEM alone would let you do.
///
/// SASS does support BEM quite well thanks to the ampersand (&) and the @at-root directive. However,
/// there is no way to make sure users adhere to the BEM or BEMIT methodology.
/// That's where the mixins in this file come into play: They automatically generate the right selectors
/// and perform checks regarding the nesting order, nesting depth, and so on.
///
/// There are comments in the mixins explaining what selector is generated. The EBNF grammar is as follows:
///
///   (* Shorthands for block, element, modifier, suffix *)
///   entity_shorthand = "b" "e" "m" "s" "t" ;
///   
///   (* One or multiple BEMIT entities that were generated with an earlier mixin invocation *)
///   existing_entities = "{" entity_shorthand { "," entity_shorthand } "}" ;
///   
///   (* A BEM entity that doesn't depend on a parent entity *)
///   generated_independent_entity = "block" ;
///   
///   (* A BEM entity that is attached to a parent entity *)
///   generated_attached_entity = existing_entities ( "__element" | "--modifier" | "@suffix" ) ;
///   
///   (* A selector created by the user, such as "&:hover", "> a", and so on *)
///   manual_selector_part = "[manual selector]" ;
///   
///   (* A part of the selector that may or may not be in the generated result *)
///   optional_selector_part = "(" ( existing_entities | manual_selector_part ) ")" ;
///   
///   (* One part of the selector *)
///   selector_part = existing_entities | manual_selector_part | optional_selector_part | generated_independent_entity | generated_attached_entity ;
///   
///   (* The whole selector *)
///   selector = selector_part { ( " " | "." ) selector_part } ;
///
/// @link https://en.bem.info/                                                                   Information about BEM
/// @link https://csswizardry.com/2015/08/bemit-taking-the-bem-naming-convention-a-step-further/ Information about BEMIT 
///
/// @group BEM
///
/// @access public
////

///
/// Character sequence for BEM elements.
///
/// @type string
///
$ig-bem-element-separator: '__' !default;

///
/// Character sequence for BEM modifiers.
///
/// @type string
///
$ig-bem-modifier-separator: '--' !default;

///
/// Character sequence for BEMIT suffixes.
///
/// @type string
///
$ig-bem-suffix-separator: '\\@' !default;

///
/// Prefixes for all BEMIT namespaces.
///
/// @prop {string} utility   ['u'] - Utility namespace
/// @prop {string} object    ['o'] - Object namespace
/// @prop {string} component ['c'] - Component namespace
/// @prop {string} layout    ['l'] - Layout namespace
/// @prop {string} scope     ['s'] - Scope namespace
/// @prop {string} theme     ['t'] - Theme namespace
///
/// @type map
///
$ig-bem-namespaces: (
    utility:   'u',
    object:    'o',
    component: 'c',
    layout:    'l',
    scope:     's',
    theme:     't',
    js:        'js',
    qa:        'qa',
    hack:      '_'
) !default;

///
/// A list of all generated BEMIT blocks. 
///
/// @type list
///
/// @access private
///
$ig-bem-blocks: ();

///
/// Maximum nesting depth of BEM mixins. The large default value means there is no effective limit.
/// 
/// @type number
///
$ig-bem-max-depth: 99 !default;

///
/// Indicates how nested elements should be handled.
///
/// 'allow' means elements will be nested, i.e. the result will be {e} {b}__element.
/// 'disallow' means an error will be emitted.
/// 'append' means the element name will be appended to the parent element, i.e. the result will be {e}__element.
/// Any other value is treated as 'allow'.
/// 
/// @type string
///
$ig-bem-element-nesting-policy: 'allow' !default;

///
/// Context ID used for all BEM-related mixins.
///
/// @type string
///
$ig-bem-context-id: 'bem' !default;

/// 
/// Generate a new BEMIT block.
///
/// This mixin simply creates a new block with the name {namespace}_{name},
/// where {namespace} is the prefix assigned to $type and {name} is the
/// block's name.
///
/// @param {string} $name        - Block name
/// @param {string} $type [null] - BEMIT namespace of the block
///
/// @content
///
/// @throw If $type is invalid
/// @throw If the block is preceded by another block, element, modifier or suffix
///
/// @example scss - Creating a new block
///   @include ig-bem-block('something', 'component') {
///     /* some definitions */
///   }
///   
///   // Generates:
///   
///   .c-something {
///     /* some definitions */
///   }
///
@mixin ig-bem-block($name, $type: null) {
    $selector: nth(ig-bem-block($name, $type), 1);

    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

///
/// Generate a new BEMIT block. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-block
///
@function ig-bem-block($name, $type: null) {
    //
    // Possible outcomes:
    //   - ({b,e,m,s}) block
    //

    $noop: ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);

    $selector:      null;
    $base-selector: null;

    @if $type != null {
        $namespace: map-get($ig-bem-namespaces, $type);

        @if not $namespace {
            @error '"#{$type}" is not a valid type.';
        }

        $base-selector: selector-parse('.' + $namespace + '-' + $name);

        @if $type != 'theme' or & {
            $selector: $base-selector;
        } @else if not & {
            $selector: ig-bem-theme-selector($name);
        }
    } @else {
        $base-selector: selector-parse('.' + $name);
        $selector:      $base-selector;
    }

    @if & {
        $selector: selector-nest(&, $selector);
        $selector: ig-selector-nest-fix($selector);
    }

    @if $type != null {
        $ig-bem-blocks: append($ig-bem-blocks, $name + '_' + $type) !global;
    } @else {
        $ig-bem-blocks: append($ig-bem-blocks, $name) !global;
    }

    $noop: ig-context-push($ig-bem-context-id, 'block', (
            'name':          $name,
            'type':          $type,
            'selector':      $selector,
            'base-selector': $base-selector
    ));

    @return $selector true;
}

/// 
/// Generate a new BEMIT object block. It's a shorthand for ig-bem-block($name, 'object').
///
/// @param {string} $name - Object block name
///
/// @content
///
@mixin ig-bem-object($name) {
    @include ig-bem-block($name, 'object') {
        @content;
    }
}

///
/// Generate a new BEMIT object block. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-object
///
@function ig-bem-object($name) {
    @return ig-bem-block($name, 'object');
}

/// 
/// Generate a new BEMIT component block. It's a shorthand for ig-bem-block($name, 'component').
///
/// @param {string} $name - Component block name
///
/// @content
///
@mixin ig-bem-component($name) {
    @include ig-bem-block($name, 'component') {
        @content;
    }
}

///
/// Generate a new BEMIT component block. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-component
///
@function ig-bem-component($name) {
    @return ig-bem-block($name, 'component');
}

/// 
/// Generate a new BEMIT layout block. It's a shorthand for ig-bem-block($name, 'layout').
///
/// @param {string} $name - Layout block name
///
/// @content
///
@mixin ig-bem-layout($name) {
    @include ig-bem-block($name, 'layout') {
        @content;
    }
}

///
/// Generate a new BEMIT layout block. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-layout
///
@function ig-bem-layout($name) {
    @return ig-bem-block($name, 'layout');
}

/// 
/// Generate a new BEMIT utility block. It's a shorthand for ig-bem-block($name, 'utility').
///
/// @param {string} $name - Utility block name
///
/// @content
///
@mixin ig-bem-utility($name) {
    @include ig-bem-block($name, 'utility') {
        @content;
    }
}

///
/// Generate a new BEMIT utility block. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-utility
///
@function ig-bem-utility($name) {
    @return ig-bem-block($name, 'utility');
}

/// 
/// Generate a new BEMIT scope block. It's a shorthand for ig-bem-block($name, 'scope').
///
/// @param {string} $name - Scope block name
///
/// @content
///
@mixin ig-bem-scope($name) {
    @include ig-bem-block($name, 'scope') {
        @content;
    }
}

///
/// Generate a new BEMIT scope block. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-scope
///
@function ig-bem-scope($name) {
    @return ig-bem-block($name, 'scope');
}

/// 
/// Generate a new BEMIT theme block. It's a shorthand for ig-bem-block($name, 'theme').
///
/// @param {string} $name - Theme block name
///
/// @content
///
@mixin ig-bem-theme($name) {
    @include ig-bem-block($name, 'theme') {
        @content;
    }
}

///
/// Generate a new BEMIT theme block. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-theme
///
@function ig-bem-theme($name) {
    @return ig-bem-block($name, 'theme');
}

/// 
/// Generate a new BEMIT JS block. It's a shorthand for ig-bem-block($name, 'js').
///
/// @param {string} $name - JS block name
///
/// @content
///
@mixin ig-bem-js($name) {
    @include ig-bem-block($name, 'js') {
        @content;
    }
}

///
/// Generate a new BEMIT JS block. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-js
///
@function ig-bem-js($name) {
    @return ig-bem-block($name, 'js');
}

/// 
/// Generate a new BEMIT QA block. It's a shorthand for ig-bem-block($name, 'qa').
///
/// @param {string} $name - QA block name
///
/// @content
///
@mixin ig-bem-qa($name) {
    @include ig-bem-block($name, 'qa') {
        @content;
    }
}

///
/// Generate a new BEMIT QA block. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-qa
///
@function ig-bem-qa($name) {
    @return ig-bem-block($name, 'qa');
}

/// 
/// Generate a new BEMIT hack block. It's a shorthand for ig-bem-block($name, 'hack').
///
/// @param {string} $name - Hack block name
///
/// @content
///
@mixin ig-bem-hack($name) {
    @include ig-bem-block($name, 'hack') {
        @content;
    }
}

///
/// Generate a new BEMIT hack block. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-hack
///
@function ig-bem-hack($name) {
    @return ig-bem-block($name, 'hack');
}

/// 
/// Assert that a block or element is composed of another block. In BEM, such a relationship is referred to
/// as a "mix": https://en.bem.info/methodology/key-concepts/#mix
///
/// Compilation will fail if the foreign block doesn't exist. This way, you can ensure that blocks are
/// defined in the right order so that composed blocks/elements will actually override the foreign
/// declarations without having to artificially increase the specificity.
///
/// @param {string | list} $block  - Either first block name, or list with two items: 1. block name, 2. block type
/// @param {string | list} $blocks - Either other block names, or list with two items: 1. block name, 2. block type
///
/// @throw If a block type is invalid 
/// @throw If a block doesn't exist
///
/// @example scss - Successful assertion
///   @include ig-bem-component('someBlock') {
///     /* some definitions */
///   }
///   
///   @include ig-bem-component('anotherBlock') {
///     /* some definitions */
///     
///     @include ig-bem-element('elem') {
///       @include ig-bem-composed-of('someBlock' 'component');
///       
///       /* some definitions */
///     }
///   }
///
///   // Intended use: <div class="c-anotherBlock__elem c-someBlock">...</div>
///
/// @example scss - Failing assertion
///   @include ig-bem-component('anotherBlock') {
///     /* some definitions */
///     
///     @include ig-bem-element('elem') {
///       @include ig-bem-composed-of('someBlock' 'component');
///       
///       /* some definitions */
///     }
///   }
///   
///   @include ig-bem-component('someBlock') {
///     /* some definitions */
///   }
///   
///   // Compilation will fail because c-someBlock is defined after c-anotherBlock__elem
///
@mixin ig-bem-composed-of($block, $blocks...) {
    @each $block in ig-list-prepend($blocks, $block) {
        @if type-of($block) == string {
            @if not index($ig-bem-blocks, $block) {
                @error 'Block "#{$block}" does not exist.';
            }
        } @else {
            $name: nth($block, 1);
            $type: nth($block, 2);

            @if not map-get($ig-bem-namespaces, $type) {
                @error '"#{$type}" is not a valid type.';
            }

            @if not index($ig-bem-blocks, $name + '_' + $type) {
                @error 'Block "#{$name}" does not exist.';
            }
        }
    }
}

/// 
/// Generate a new BEM element.
///
/// The element will be generated according to the BEM naming convention.
/// If the parent selector doesn't match the block selector, the element will be
/// nested inside the parent selector. This means, you may nest elements inside
/// other elements, modifiers or any kind of selector such as &:hover.
///
/// @param {string} $name  - First element name
/// @param {string} $names - More element names
///
/// @content
///
/// @throw If the element is not preceded by a block, element, modifier or suffix.
///
/// @example scss - Element for a block
///   @include ig-bem-component('block') {
///     /* some block definitions */
///     
///     @include ig-bem-element('elem') {
///       /* some element definitions */
///     }
///   }
///   
///   // Generates:
///   
///   .c-block {
///     /* some block definitions */
///   }
///   
///   .c-block__elem {
///     /* some element definitions */
///   }
///
/// @example scss - Element that is affected by the user hovering the block
///   @include ig-bem-component('block') {
///     /* some block definitions */
///     
///     @include ig-bem-element('elem') {
///       background-color: #eee;
///     }
///     
///     &:hover {
///       @include ig-bem-element('elem') {
///         background-color: #000;
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block {
///     /* some block definitions */
///   }
///   
///   .c-block__elem {
///     background-color: #eee;
///   }
///   
///   .c-block:hover .c-block__elem {
///     background-color: #000;
///   }
///
/// @example scss - Multiple elements
///   @include ig-bem-component('block') {
///     /* some block definitions */
///     
///     @include ig-bem-element('elem1', 'elem2') {
///       /* some element definitions */
///     }
///   }
///   
///   // Generates:
///   
///   .c-block {
///     /* some block definitions */
///   }
///   
///   .c-block__elem1, .c-block__elem2 {
///     /* some element definitions */
///   }
///
@mixin ig-bem-element($name, $names...) {
    $selector: nth(ig-bem-element($name, $names...), 1);

    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

///
/// Generate a new BEM element. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-element
///
@function ig-bem-element($name, $names...) {
    $noop: ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    $noop: ig-context-assert-stack-must-contain($ig-bem-context-id, 'block');

    $parent-context: ig-context-get($ig-bem-context-id, 'block' 'element' 'at-theme');

    $selector:   ();
    $parts-data: ();

    @if nth($parent-context, 1) == 'element' {
        @if $ig-bem-element-nesting-policy == 'disallow' {
            @error 'Element nesting is forbidden.';
        }

        $element-selector: map-get(nth($parent-context, 2), 'selector');

        @if $ig-bem-element-nesting-policy == 'append' {
            @if not is-superselector(&, $element-selector) {
                @error 'A nested element must be an immediate children of the parent element.';
            }

            //
            // Possible outcomes:
            //   - {e}__element
            //

            @each $name in join($name, $names) {
                $sel:        selector-append(&, $ig-bem-element-separator + $name);
                $selector:   join($selector, $sel, comma);
                $parts-data: append($parts-data, (
                        'name':     $name,
                        'selector': $sel
                ));
            }
        }

        $parent-context: ig-context-get($ig-bem-context-id, 'block' 'at-theme');
    }

    @if length($selector) == 0 {
        $parent-selector: map-get(nth($parent-context, 2), 'selector');

        @if is-superselector(&, $parent-selector) {
            //
            // Possible outcomes:
            //   - {b}__element
            //

            @each $name in join($name, $names) {
                $sel:        selector-append(&, $ig-bem-element-separator + $name);
                $selector:   join($selector, $sel, comma);
                $parts-data: append($parts-data, (
                        'name':     $name,
                        'selector': $sel
                ));
            }
        } @else {
            //
            // Possible outcomes:
            //   - {b} [manual selector] {b}__element
            //   - {e,m,s} ([manual selector]) {b}__element
            //

            @if nth($parent-context, 1) != 'block' {
                $parent-context: ig-context-get($ig-bem-context-id, 'block');
            }

            $block-base-selector: map-get(nth($parent-context, 2), 'base-selector');

            @each $name in join($name, $names) {
                $sel:        selector-nest(&, selector-append($block-base-selector, $ig-bem-element-separator + $name));
                $sel:        ig-selector-nest-fix($sel);
                $selector:   join($selector, $sel, comma);
                $parts-data: append($parts-data, (
                        'name':     $name,
                        'selector': $sel
                ));
            }
        }
    }

    $noop: ig-context-push($ig-bem-context-id, 'element', (
            'parts':    $parts-data,
            'selector': $selector
    ));

    @return $selector true;
}

/// 
/// Generate a BEM element that is related to the current element.
///
/// The generated element selector is appended to the current element selector. The $sign
/// determines the relationship.
///
/// @param {string} $sign  - Relationshop sign, either '+' or '~'
/// @param {string} $name  - First element name
/// @param {string} $names - More element names
///
/// @content
///
/// @throw If the element is not preceded by an element.
///
/// @example scss - A sibling element to a single element
///   @include ig-bem-component('block') {
///     @include ig-bem-element('elem') {
///       /* some element definitions */
///       
///       @include ig-bem-related-element('~', 'sibling') {
///         /* some sibling element definitions */
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block__elem {
///     /* some element definitions */
///   }
///   
///   .c-block__elem ~ .c-block__sibling {
///     /* some sibling element definitions */
///   }
///
/// @example scss - A successor element to a single element
///   @include ig-bem-component('block') {
///     @include ig-bem-element('elem') {
///       /* some element definitions */
///       
///       @include ig-bem-related-element('+', 'successor') {
///         /* some successor element definitions */
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block__elem {
///     /* some element definitions */
///   }
///   
///   .c-block__elem + .c-block__successor {
///     /* some successor element definitions */
///   }
///
/// @example scss - A successor element to multiple elements
///   @include ig-bem-component('block') {
///     @include ig-bem-element('elem1', 'elem2') {
///       /* some element definitions */
///       
///       @include ig-bem-related-element('+', 'successor') {
///         /* some successor element definitions */
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block__elem1, .c-block__elem2 {
///     /* some element definitions */
///   }
///   
///   .c-block__elem1 + .c-block__successor, .c-block__elem2 + .c-block__successor {
///     /* some successor element definitions */
///   }
///
@mixin ig-bem-related-element($sign, $name, $names...) {
    $selector: nth(ig-bem-related-element($sign, $name, $names...), 1);

    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

///
/// Generate a new BEM element that is related to the current element.
/// Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-related-element
///
@function ig-bem-related-element($sign, $name, $names...) {
    //
    // Generating this selector is simple: Take the latest block context, use it
    // to generate the element part, and insert it at the end of the current selector.
    // Possible outcomes:
    //   - {e} ({m,s}) ([manual selector]) + {e}
    //   - {e} ({m,s}) ([manual selector]) ~ {e}
    //

    $noop: ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    $noop: ig-context-assert-stack-must-contain($ig-bem-context-id, 'element');

    @if $sign != '+' and $sign != '~' {
        @error 'Invalid relationship sign #{inspect($sign)}.';
    }

    $block-context:       ig-context-get($ig-bem-context-id, 'block');
    $block-base-selector: map-get(nth($block-context, 2), 'base-selector');

    $selector:   ();
    $parts-data: ();

    @each $name in join($name, $names) {
        $sel:        selector-nest(&, $sign, selector-append($block-base-selector, $ig-bem-element-separator + $name));
        $sel:        ig-selector-nest-fix($sel);
        $selector:   join($selector, $sel, comma);
        $parts-data: append($parts-data, (
                'name':     $name,
                'selector': $sel
        ));
    }

    $noop: ig-context-push($ig-bem-context-id, 'element', (
            'parts':    $parts-data,
            'selector': $selector
    ));

    @return $selector true;
}

/// 
/// Generate a BEM element that is a sibling of the current element.
///
/// It's a shorthand for ig-bem-related-element('~', $name).
///
/// @param {string} $name  - First element name
/// @param {list}   $names - List of more element names
///
/// @content
///
@mixin ig-bem-sibling-element($name, $names...) {
    @include ig-bem-related-element('~', $name, $names...) {
        @content;
    }
}

///
/// Generate a new BEM element that is a sibling of the current element.
/// Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-sibling-element
///
@function ig-bem-sibling-element($name, $names...) {
    @return ig-bem-related-element('~', $name, $names...);
}

/// 
/// Generate a BEM element that is the successor of the current element.
///
/// It's a shorthand for ig-bem-related-element('+', $name).
///
/// @param {string} $name  - First element name
/// @param {string} $names - More element names
///
/// @content
///
@mixin ig-bem-next-element($name, $names...) {
    @include ig-bem-related-element('+', $name, $names...) {
        @content;
    }
}

///
/// Generate a new BEM element that is the successor of the current element.
/// Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-next-element
///
@function ig-bem-next-element($name, $names...) {
    @return ig-bem-related-element('+', $name, $names...);
}

/// 
/// Generate the current BEM element as a successor of itself.
///
/// If this is applied to a single element, it behaves exactly the same as
/// ig-bem-related-element('+', name);
/// However, if it is applied to multiple elements, each twin element only will influence
/// their other twin, which is not replicable with ig-bem-related-element.
///
/// @content
///
/// @example scss - Two twin elements
///   @include ig-bem-component('block') {
///     @include ig-bem-element('elem') {
///       /* some element definitions */
///       
///       @include ig-bem-next-twin-element {
///         /* some twin element definitions */
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block__elem {
///     /* some element definitions */
///   }
///   
///   .c-block__elem + .c-block__elem {
///     /* some twin element definitions */
///   }
///
/// @example scss - Multiple twin elements
///   @include ig-bem-component('block') {
///     @include ig-bem-element('elem1', 'elem2') {
///       /* some element definitions */
///       
///       @include ig-bem-next-twin-element {
///         /* some twin element definitions */
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block__elem1, .c-block__elem2 {
///     /* some element definitions */
///   }
///   
///   .c-block__elem1 + .c-block__elem1, .c-block__elem2 + .c-block__elem2 {
///     /* some twin element definitions */
///   }
///
@mixin ig-bem-next-twin-element {
    $selector: nth(ig-bem-next-twin-element(), 1);

    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

///
/// Generate the current BEM element as a successor of itself.
/// Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-next-twin-element
///
@function ig-bem-next-twin-element() {
    $noop: ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    $noop: ig-context-assert-stack-must-contain($ig-bem-context-id, 'element');

    $element-context:  ig-context-get($ig-bem-context-id, 'element');
    $element-selector: map-get(nth($element-context, 2), 'selector');

    $block-context:       ig-context-get($ig-bem-context-id, 'block');
    $block-base-selector: map-get(nth($block-context, 2), 'base-selector');

    $selector:   ();
    $parts-data: ();

    //
    // To determine the twin for each element, iterate the sub-selectors from the current selector
    // and check if it contains the currently inspected element. This has to be done with string
    // comparison since none of SASS selector functions is of use here.
    // Finally, the current twin will be appended to the extracted sub-selector as a successor
    // element.
    //
    @each $part-data in map-get(nth($element-context, 2), 'parts') {
        $part-selector: map-get($part-data, 'selector');
        $part-name:     map-get($part-data, 'name');

        $sel: ();
        @if is-superselector(&, $element-selector) {
            //
            // This mixin is included in the selector the last element mixin created.
            // Possible outcomes:
            //   - {e} + {e}
            //

            @each $s in & {
                @each $ps in $part-selector {
                    @if $s == $ps {
                        $sel-ent: selector-nest($s, '+', selector-append($block-base-selector, $ig-bem-element-separator + $part-name));
                        $sel-ent: ig-selector-nest-fix($sel-ent);
                        $sel:     append($sel, $sel-ent, comma);
                    }
                }
            }
        } @else {
            //
            // This mixin is NOT included in the selector the last element mixin created.
            // Possible outcomes:
            //   - {e} {m,s} + {e}
            //   - {e} [manual selector] + {e}
            //   - {e} {m,s} [manual selector] + {e}
            //

            @each $s in & {
                @each $ps in $part-selector {
                    @if str-index(inspect($s), inspect($ps)) == 1 {
                        $char-index: str-length(inspect($ps)) + 1;
                        $match:      index(' ' ':' ',', str-slice(inspect($s), $char-index, $char-index)) != null;

                        @if not $match {
                            @each $separator in $ig-bem-element-separator $ig-bem-modifier-separator $ig-bem-suffix-separator {
                                @if str-slice(inspect($s), $char-index, $char-index + str-length($separator) - 1) == $separator {
                                    $match: true;
                                }
                            }
                        }

                        @if $match {
                            $sel-ent: selector-nest($s, '+', selector-append($block-base-selector, $ig-bem-element-separator + $part-name));
                            $sel-ent: ig-selector-nest-fix($sel-ent);
                            $sel:     append($sel, $sel-ent, comma);
                        }
                    }
                }
            }
        }
        @if length($sel) != length($part-selector) {
            @error 'Could not generate twin element selector.';
        }

        $selector:   join($selector, $sel, comma);
        $parts-data: append($parts-data, (
                'name':     $part-name,
                'selector': $sel
        ));
    }

    $noop: ig-context-push($ig-bem-context-id, 'element', (
            'parts':    $parts-data,
            'selector': $selector
    ));

    @return $selector true;
}

/// 
/// Generate a new BEM modifier.
/// 
/// If the parent context is block or element, the modifier will modify said block or element according
/// to the BEM naming convention.
///
/// If the parent context is a modifier or suffix, then the modifier will depend on said modifier or suffix.
/// Depending on $extend, the meaning of this dependency (and the resulting selector) varies:
/// If it's false (default), you signalize that the modifier also exists by itself, but it changes its
/// behavior when the parent modifier or suffix is set.
/// If it's true, you signalize that the modifier extends the parent modifier or suffix and can only be
/// used in conjunction with it.
///
/// @param {string | list} $name  - First element name or list with two items: 1. first element name, 2. bool indicating if the modifier is extending
/// @param {string | list} $names - More element names or lists with two items: 1. element name, 2. bool indicating if the modifier is extending
///
/// @content
///
/// @throw If the element is not preceded by a block, element, modifier or suffix.
///
/// @example scss - Modifier that modifies a block or element
///   @include ig-bem-component('block') {
///     @include ig-bem-modifier('mod') {
///       background-color: #eee;
///     }
///     
///     @include ig-bem-element('elem') {
///       @include ig-bem-modifier('mod') {
///         background-color: #222;
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block--mod {
///     background-color: #eee;
///   }
///   
///   .c-block__elem--mod {
///     background-color: #222;
///   }
///
/// @example scss - Modifier nested in another modifier, not extending
///   @include ig-bem-component('block') {
///     @include ig-bem-modifier('mod') {
///       background-color: #eee;
///     }
///     
///     @include ig-bem-modifier('dark') {
///       /* some definitions */
///       
///       @include ig-bem-modifier('mod') {
///         background-color: #222;
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block--mod {
///     background-color: #eee;
///   }
///   
///   .c-block--dark {
///     /* some definitions */
///   }
///   
///   .c-block--dark.c-block--mod {
///     background-color: #222;
///   }
///
/// @example scss - Modifier nested in another modifier, extending
///   @include ig-bem-component('block') {
///     @include ig-bem-modifier('mod') {
///       background-color: #eee;
///     }
///     
///     @include ig-bem-modifier('dark') {
///       /* some definitions */
///       
///       @include ig-bem-modifier('mod' true) {
///         background-color: #222;
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .c-block--mod {
///     background-color: #eee;
///   }
///   
///   .c-block--dark {
///     /* some definitions */
///   }
///   
///   .c-block--dark--mod {
///     background-color: #222;
///   }
///
@mixin ig-bem-modifier($name, $names...) {
    $selector: nth(ig-bem-modifier($name, $names...), 1);

    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

///
/// Generate a new BEM modifier. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-modifier
///
@function ig-bem-modifier($name, $names...) {
    $noop: ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    $noop: ig-context-assert-stack-must-contain($ig-bem-context-id, 'block');

    $parent-context:  ig-context-get($ig-bem-context-id, 'block' 'element' 'modifier' 'suffix' 'at-theme');
    $parent-selector: map-get(nth($parent-context, 2), 'selector');
    $selector:        ();
    $parts-data:      ();

    @if not is-superselector(&, $parent-selector) {
        //
        // The current selector doesn't match the parent selector.
        // The user manually added a selector between parent context and this modifier call.
        // This case is forbidden because any outcome semantically wouldn't make sense:
        //   - {b,e,m,s} [manual selector] {b,e,m,s}--modifier
        //   - {b,e,m,s}--modifier [manual selector]
        // The first case would make the modifier behave like an element.
        // The second case is unintuitive, the code would be more clear by nesting the manual
        // selector in the modifier instead.
        //

        @error 'A modifier must be an immediate child of the parent context';
    }

    @each $name in ig-list-prepend($names, $name) {
        $extend: false;
        @if type-of($name) == list {
            $extend: nth($name, 2);
            $name:   nth($name, 1);
        }

        @if index('block' 'element' 'at-theme', nth($parent-context, 1)) or $extend == true {
            //
            // Either the parent context is block or element, or a modifier or suffix
            // is to be extended. The modifier part can simply be appended.
            // Possible outcomes:
            //   - {b,e,m,s}--modifier
            //

            $sel:        selector-append(&, $ig-bem-modifier-separator + $name);
            $selector:   join($selector, $sel, comma);
            $parts-data: append($parts-data, (
                    'name':     $name,
                    'selector': $sel
            ));
        } @else {
            //
            // Parent context is modifier or suffix and $extend is false. Get latest element or block.
            //

            $be-context: ig-context-get($ig-bem-context-id, 'block' 'element');

            @if nth($be-context, 1) == 'element' {
                //
                // Latest context is element. Since element contexts can consist of multiple single
                // elements, inspect all elements and append its selector with the suffix "--$name".
                // This has to be done with string comparison since none of SASS selector functions
                // is of use here. 
                // Possible outcomes:
                //   - {m,s}.{e}--modifier
                //

                $nsel: ();

                @each $elem-part-data in map-get(nth($be-context, 2), 'parts') {
                    $elem-part-selector: map-get($elem-part-data, 'selector');

                    $sel: ();
                    @each $s in & {
                        @each $ps in $elem-part-selector {
                            @if (str-index(inspect($s), inspect($ps) + $ig-bem-modifier-separator) == 1) or (str-index(inspect($s), inspect($ps) + $ig-bem-suffix-separator) == 1) {
                                $sel: append($sel, selector-unify($s, selector-append($ps, $ig-bem-modifier-separator + $name)), comma);
                            }
                        }
                    }
                    @if length($sel) == 0 {
                        @error 'Could not generate modifier selector.';
                    }

                    $nsel: join($nsel, $sel, comma);
                }

                $selector:   join($selector, $nsel, comma);
                $parts-data: append($parts-data, (
                        'name':     $name,
                        'selector': $nsel
                ));
            } @else {
                //
                // Latest context is block. Just append the modifier part.
                // Possible outcomes:
                //   - {m,s}.{b}--modifier
                //

                $block-base-selector: map-get(nth($be-context, 2), 'base-selector');

                $sel:        selector-append(&, $block-base-selector, $ig-bem-modifier-separator + $name);
                $selector:   join($selector, $sel, comma);
                $parts-data: append($parts-data, (
                        'name':     $name,
                        'selector': $sel
                ));
            }
        }
    }

    $noop: ig-context-push($ig-bem-context-id, 'modifier', (
            'parts':    $parts-data,
            'selector': $selector
    ));

    @return $selector true;
}

/// 
/// Generate a new BEMIT suffix.
///
/// @param {string} $name - Suffix name
///
/// @content
///
/// @throw If the element is not preceded by a block or modifier.
///
/// @example scss - Using a suffix
///   @include ig-bem-utility('hidden') {
///     display: none;
///     
///     @media (max-width: 320px) {
///       @include ig-bem-suffix('phone') {
///         display: none;
///       }
///     }
///     
///     @media (max-width: 768px) {
///       @include ig-bem-suffix('tablet') {
///         display: none;
///       }
///     }
///   }
///   
///   // Generates:
///   
///   .u-hidden {
///     display: none;
///   }
///   
///   @media (max-width: 320px) {
///     .u-hidden@phone {
///       display: none;
///     }
///   }
///   
///   @media (max-width: 768px) {
///     .u-hidden@tablet {
///       display: none;
///     }
///   }
///
@mixin ig-bem-suffix($name) {
    $selector: nth(ig-bem-suffix($name), 1);

    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

///
/// Generate a new BEMIT suffix. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-suffix
///
@function ig-bem-suffix($name) {
    //
    // Suffixes can be used on block, element and modifier.
    //

    $noop: ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);
    $noop: ig-context-assert-stack-must-contain($ig-bem-context-id, 'block');
    $noop: ig-context-assert-stack-must-not-contain($ig-bem-context-id, 'suffix');

    $parent-context:  ig-context-get($ig-bem-context-id, 'block' 'element' 'modifier' 'at-theme');
    $parent-selector: map-get(nth($parent-context, 2), 'selector');

    @if not is-superselector(&, $parent-selector) {
        //
        // The current selector doesn't match the parent selector.
        // The user manually added a selector between parent context and this suffix call.
        // This case is forbidden because any outcome semantically wouldn't make sense:
        //   - {b,e,m} [manual selector] {b,e,m}@suffix
        //   - {b,e,m}@suffix [manual selector]
        // The first case would make the modifier behave like an element.
        // The second case is unintuitive, the code would be more clear by nesting the manual
        // selector in the suffix instead.
        //

        @error 'A suffix must be an immediate child of the parent context';
    }

    //
    // The suffix part can simply be appended.
    // Possible outcomes:
    //   - {b,e,m}@suffix
    //

    $selector: selector-append(&, $ig-bem-suffix-separator + $name);

    $noop: ig-context-push($ig-bem-context-id, 'suffix', (
            'name':     $name,
            'selector': $selector
    ));

    @return $selector true;
}

/// 
/// Create a new is-state modifier.
///
/// @param {string} $state  - First state name
/// @param {list}   $states - List of more state names
///
/// @content
///
/// @example scss - Using single is-state
///   @include ig-bem-object('menu') {
///     display: none;
///     
///     @include ig-bem-is('open') {
///       display: block;
///     }
///   }
///   
///   // Generates:
///   
///   .o-menu {
///     display: none;
///   }
///   
///   .o-menu.is-open {
///     display: block;
///   }
///
/// @example scss - Using multiple is-states
///   @include ig-bem-object('menu') {
///     display: none;
///     
///     @include ig-bem-is('open', 'visible') {
///       display: block;
///     }
///   }
///   
///   // Generates:
///   
///   .o-menu {
///     display: none;
///   }
///   
///   .o-menu.is-open,
///   .o-menu.is-visible {
///     display: block;
///   }
///
@mixin ig-bem-is($state, $states...) {
    $selector: nth(ig-bem-is($state, $states...), 1);

    @at-root #{$selector} {
        @content;
    }
}

///
/// Generate a new is-state modifier. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-is
///
@function ig-bem-is($state, $states...) {
    $selector: ();

    @each $state in join($state, $states) {
        $sel:      '&.is-#{$state}';
        $sel:      if(&, selector-nest(&, $sel), selector-parse($sel));
        $sel:      ig-selector-nest-fix($sel);
        $selector: join($selector, $sel, comma);
    }

    @return $selector false;
}

/// 
/// Create a new has-state modifier.
///
/// @param {string} $state  - First state name
/// @param {list}   $states - List of more state names
///
/// @content
///
/// @example scss - Using single has-state
///   @include ig-bem-object('buttonstrip') {
///     display: none;
///     
///     @include ig-bem-has('buttons') {
///       display: block;
///     }
///   }
///   
///   // Generates:
///   
///   .o-buttonstrip {
///     display: none;
///   }
///   
///   .o-buttonstrip.has-buttons {
///     display: block;
///   }
///
/// @example scss - Using multiple has-states
///   @include ig-bem-object('buttonstrip') {
///     display: none;
///     
///     @include ig-bem-has('buttons', 'textfields') {
///       display: block;
///     }
///   }
///   
///   // Generates:
///   
///   .o-buttonstrip {
///     display: none;
///   }
///   
///   .o-buttonstrip.has-buttons,
///   .o-buttonstrip.has-textfields {
///     display: block;
///   }
///
@mixin ig-bem-has($state, $states...) {
    $selector: nth(ig-bem-has($state, $states...), 1);

    @at-root #{$selector} {
        @content;
    }
}

///
/// Generate a new has-state modifier. Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-has
///
@function ig-bem-has($state, $states...) {
    $selector: ();

    @each $state in join($state, $states) {
        $sel:      '&.has-#{$state}';
        $sel:      if(&, selector-nest(&, $sel), selector-parse($sel));
        $sel:      ig-selector-nest-fix($sel);
        $selector: join($selector, $sel, comma);
    }

    @return $selector false;
}

/// 
/// Declare new rules for the current block for when this theme is active.
///
/// @param {string} $name  - First theme block name
/// @param {string} $names - More theme block names
///
/// @content
///
@mixin ig-bem-at-theme($name, $names...) {
    $selector: nth(ig-bem-at-theme($name, $names...), 1);

    @at-root #{$selector} {
        @content;
    }
    @include ig-context-pop($ig-bem-context-id);
}

///
/// Declare new rules for the current block for when this theme is active.
/// Check the respective mixin documentation for more information.
/// 
/// @return {list} A list with two items: 1. selector, 2. true if context was created, otherwise false
///
/// @see {mixin} ig-bem-at-theme
///
@function ig-bem-at-theme($name, $names...) {
    $noop: ig-context-assert-stack-must-contain($ig-bem-context-id, 'block');

    $parent-context:  ig-context-get($ig-bem-context-id, 'block');
    $parent-selector: map-get(nth($parent-context, 2), 'selector');

    @if not is-superselector(&, $parent-selector) {
        @error 'An at-theme rule must be an immediate child of a block or another at-theme rule';
    }

    $selector: ig-bem-theme-selector($name, $names...);
    $selector: selector-nest($selector, &);
    $selector: ig-selector-nest-fix($selector);

    $noop: ig-context-push($ig-bem-context-id, 'at-theme', (
            'name':     join($name, $names),
            'selector': $selector
    ));

    @return $selector true;
}

/// 
/// Generate multiple entities (BEM or not) at once.
///
/// NOTE: This mixin does not generate perfectly optimized selectors in order to keep track of contexts.
///
/// @param {string | list} $first  - First selector. Either a string for a manual selector, or a list with the first items standing for a BEM selector function and other items being passed as argument to said function.
/// @param {string | list} $others - Other selectors. Either a string for a manual selector, or a list with the first items standing for a BEM selector function and other items being passed as argument to said function.
///
/// @content
///
/// @example scss - Creating multiple elements and a modifier
///   @include ig-bem-object('buttonstrip') {
///     display: none;
///     
///     @include ig-bem-multi('modifier' 'mod', 'element' 'button' 'separator') {
///       display: block;
///     }
///   }
///   
///   // Generates:
///   
///   .o-buttonstrip {
///     display: none;
///   }
///   
///   .o-buttonstrip--mod {
///     display: block;
///   }
///   
///   .o-buttonstrip__button, {
///   .o-buttonstrip__separator {
///     display: block;
///   }
///
@mixin ig-bem-multi($first, $others...) {
    @include ig-context-assert-stack-count($ig-bem-context-id, $ig-bem-max-depth);

    @each $entity in ig-list-prepend($others, $first) {
        $is-manual-selector: false;

        @if type-of($entity) == string and not function-exists('ig-bem-' + $entity) {
            $is-manual-selector: true;
        }

        @if $is-manual-selector {
            $sel: if(&, selector-nest(&, $entity), selector-parse($entity));
            $sel: ig-selector-nest-fix($sel);

            @at-root #{$sel} {
                @content;
            }
        } @else {
            $entity-func-id: null;

            @if type-of($entity) == list {
                $entity-func-id: nth($entity, 1);
                $entity:         ig-list-slice($entity, 2);
            } @else {
                $entity-func-id: $entity;
                $entity:         ();
            }

            @if str-slice($entity-func-id, str-length($entity-func-id)) == ':' {
                $entity-func-id: str-slice($entity-func-id, 1, str-length($entity-func-id) - 1);
            }

            @if $entity-func-id == 'multi' {
                @error 'ig-bem-multi cannot call itself.';
            }

            $sel-func: null;

            @if function-exists('ig-bem-' + $entity-func-id) {
                $sel-func: get-function('ig-bem-' + $entity-func-id);
            } @else if function-exists($entity-func-id) {
                $sel-func: get-function($entity-func-id);
            }

            @if $sel-func == null {
                @error 'Function "#{inspect($entity-func-id)}" was not found.';
            }

            $entity-data: call($sel-func, $entity...);

            @at-root #{nth($entity-data, 1)} {
                @content;
            }

            @if nth($entity-data, 2) {
                @include ig-context-pop($ig-bem-context-id);
            }
        }
    }
}

//

//
// @access private
//
@function ig-bem-theme-selector($name, $names...) {
    $namespace: map-get($ig-bem-namespaces, 'theme');
    $selector:  null;

    @each $name in join($name, $names) {
        $sel: '.' + $namespace + '-' + $name;

        @if $selector == null {
            $selector: join(selector-parse($sel), selector-parse('[class*=\' t-\'] ' + $sel), comma);
        } @else {
            $selector: selector-nest($selector, $sel);
            $selector: ig-selector-nest-fix($selector);
        }
    }

    @return $selector;
}

@include ig-context-stack-create($ig-bem-context-id);
